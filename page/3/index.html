<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="say something about me">
<meta property="og:type" content="website">
<meta property="og:title" content="BlankLin">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="BlankLin">
<meta property="og:description" content="say something about me">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Blank Lin">
<meta property="article:tag" content="lazy and boring">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>BlankLin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="BlankLin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BlankLin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">lazy and boring</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/21/clickhouse-read-timed-out/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/21/clickhouse-read-timed-out/" class="post-title-link" itemprop="url">ClickHouse Read Timed Out追踪过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 19:28:55" itemprop="dateCreated datePublished" datetime="2021-12-21T19:28:55+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>最近经常遇到<code>Read timed out</code>报错，具体内容看下面，从字面意思判断我们知道是读超时，那为什么会发生读超时呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ru.yandex.clickhouse.except.ClickHouseException: ClickHouse exception, code: 159, host: bigdata-clickhouse-xxxx.ys, port: 8023; Read timed out	at ru.yandex.clickhouse.except.ClickHouseExceptionSpecifier.getException(ClickHouseExceptionSpecifier.java:86)	at ru.yandex.clickhouse.except.ClickHouseExceptionSpecifier.specify(ClickHouseExceptionSpecifier.java:56)	at ru.yandex.clickhouse.except.ClickHouseExceptionSpecifier.specify(ClickHouseExceptionSpecifier.java:25)	at ru.yandex.clickhouse.ClickHouseStatementImpl.getInputStream(ClickHouseStatementImpl.java:797)	at ru.yandex.clickhouse.ClickHouseStatementImpl.getLastInputStream(ClickHouseStatementImpl.java:691)	at ru.yandex.clickhouse.ClickHouseStatementImpl.executeQuery(ClickHouseStatementImpl.java:340)	at ru.yandex.clickhouse.ClickHouseStatementImpl.executeQuery(ClickHouseStatementImpl.java:324)	at ru.yandex.clickhouse.ClickHouseStatementImpl.executeQuery(ClickHouseStatementImpl.java:319)	at ru.yandex.clickhouse.ClickHouseStatementImpl.executeQuery(ClickHouseStatementImpl.java:314)	at</span><br></pre></td></tr></table></figure></p>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><ul>
<li>从抛出的堆栈入手，先读<code>ru.yandex.clickhouse.except.ClickHouseExceptionSpecifier</code>类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * Here we expect the ClickHouse error message to be of the following format:</span><br><span class="line">  * &quot;Code: 10, e.displayText() &#x3D; DB::Exception: ...&quot;.</span><br><span class="line">  *&#x2F;</span><br><span class="line">private static ClickHouseException specify(String clickHouseMessage, Throwable cause, String host, int port) &#123;</span><br><span class="line">    if (Utils.isNullOrEmptyString(clickHouseMessage) &amp;&amp; cause !&#x3D; null) &#123;</span><br><span class="line">        return getException(cause, host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        int code;</span><br><span class="line">        if (clickHouseMessage.startsWith(&quot;Poco::Exception. Code: 1000, &quot;)) &#123;</span><br><span class="line">            code &#x3D; 1000;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Code: 175, e.displayText() &#x3D; DB::Exception:</span><br><span class="line">            code &#x3D; getErrorCode(clickHouseMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; ошибку в изначальном виде все-таки укажем</span><br><span class="line">        Throwable messageHolder &#x3D; cause !&#x3D; null ? cause : new Throwable(clickHouseMessage);</span><br><span class="line">        if (code &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            return getException(messageHolder, host, port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ClickHouseException(code, messageHolder, host, port);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;Unsupported ClickHouse error format, please fix ClickHouseExceptionSpecifier, message: &#123;&#125;, error: &#123;&#125;&quot;, clickHouseMessage, e.getMessage());</span><br><span class="line">        return new ClickHouseUnknownException(clickHouseMessage, cause, host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static ClickHouseException getException(Throwable cause, String host, int port) &#123;</span><br><span class="line">        if (cause instanceof SocketTimeoutException)</span><br><span class="line">        &#x2F;&#x2F; if we&#39;ve got SocketTimeoutException, we&#39;ll say that the query is not good. This is not the same as SOCKET_TIMEOUT of clickhouse</span><br><span class="line">        &#x2F;&#x2F; but it actually could be a failing ClickHouse</span><br><span class="line">        &#123;</span><br><span class="line">            return new ClickHouseException(ClickHouseErrorCode.TIMEOUT_EXCEEDED.code, cause, host, port);</span><br><span class="line">        &#125; else if (cause instanceof ConnectTimeoutException || cause instanceof ConnectException)</span><br><span class="line">        &#x2F;&#x2F; couldn&#39;t connect to ClickHouse during connectTimeout</span><br><span class="line">        &#123;</span><br><span class="line">            return new ClickHouseException(ClickHouseErrorCode.NETWORK_ERROR.code, cause, host, port);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ClickHouseUnknownException(cause, host, port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
注意到上文中异常类型是<code>SocketTimeoutException</code>，为啥会是这个异常呢？</li>
<li>继续阅读<code>ru.yandex.clickhouse.ClickHouseStatementImpl</code>类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private InputStream getInputStream(</span><br><span class="line">  ClickHouseSqlStatement parsedStmt,</span><br><span class="line">  Map&lt;ClickHouseQueryParam, String&gt; additionalClickHouseDBParams,</span><br><span class="line">  List&lt;ClickHouseExternalData&gt; externalData,</span><br><span class="line">  Map&lt;String, String&gt; additionalRequestParams</span><br><span class="line">) throws ClickHouseException &#123;</span><br><span class="line">  .............................</span><br><span class="line">  HttpEntity entity &#x3D; null;</span><br><span class="line">  try &#123;</span><br><span class="line">      uri &#x3D; followRedirects(uri);</span><br><span class="line">      HttpPost post &#x3D; new HttpPost(uri);</span><br><span class="line">      post.setEntity(requestEntity);</span><br><span class="line"></span><br><span class="line">      if (parsedStmt.isIdemponent()) &#123;</span><br><span class="line">          httpContext.setAttribute(&quot;is_idempotent&quot;, Boolean.TRUE);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          httpContext.removeAttribute(&quot;is_idempotent&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      HttpResponse response &#x3D; client.execute(post, httpContext);</span><br><span class="line">      entity &#x3D; response.getEntity();</span><br><span class="line">      checkForErrorAndThrow(entity, response);</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      if (entity.isStreaming()) &#123;</span><br><span class="line">          is &#x3D; entity.getContent();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          FastByteArrayOutputStream baos &#x3D; new FastByteArrayOutputStream();</span><br><span class="line">          entity.writeTo(baos);</span><br><span class="line">          is &#x3D; baos.convertToInputStream();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; retrieve response summary</span><br><span class="line">      if (isQueryParamSet(ClickHouseQueryParam.SEND_PROGRESS_IN_HTTP_HEADERS, additionalClickHouseDBParams, additionalRequestParams)) &#123;</span><br><span class="line">          Header summaryHeader &#x3D; response.getFirstHeader(&quot;X-ClickHouse-Summary&quot;);</span><br><span class="line">          currentSummary &#x3D; summaryHeader !&#x3D; null ? Jackson.getObjectMapper().readValue(summaryHeader.getValue(), ClickHouseResponseSummary.class) : null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return is;</span><br><span class="line">  &#125; catch (ClickHouseException e) &#123;</span><br><span class="line">      throw e;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      log.info(&quot;Error during connection to &#123;&#125;, reporting failure to data source, message: &#123;&#125;&quot;, properties, e.getMessage());</span><br><span class="line">      EntityUtils.consumeQuietly(entity);</span><br><span class="line">      log.info(&quot;Error sql: &#123;&#125;&quot;, sql);</span><br><span class="line">      throw ClickHouseExceptionSpecifier.specify(e, properties.getHost(), properties.getPort());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意到这是建立一个<code>http</code>连接，使用<code>post</code>方式，等到数据传输完成，返回执行结果，如果有任何<code>ClickHouseException</code>则直接抛掉，否则捕获未知异常<code>Exception</code>，格式化成固定文本的错误信息，这个错误信息就是在<code>ClickHouseExceptionSpecifier.specify</code>方法里被处理成<code>Code: 10, e.displayText() = DB::Exception: ...</code>这种结构。<br>所以回到上面的结论，就是说这个<code>http</code>连接出现异常，未等到结果，抛出了<code>SocketTimeoutException</code>，那么根据这个异常，我们可以定位到根本原因了</li>
<li>接着看<code>java.net.SocketTimeoutException</code>类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Signals that a timeout has occurred on a socket read or accept.</span><br><span class="line"> *</span><br><span class="line"> * @since   1.4</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class SocketTimeoutException extends java.io.InterruptedIOException &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -8846654841826352300L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a new SocketTimeoutException with a detail</span><br><span class="line">     * message.</span><br><span class="line">     * @param msg the detail message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SocketTimeoutException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Construct a new SocketTimeoutException with no detailed message.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SocketTimeoutException() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个类非常简短，但是很清晰告诉我们，会抛出<code>SocketTimeoutException</code>异常的原因只能是一个<code>socket</code>读取或者接收时发生了超时</li>
<li>题外话什么是<code>socket</code><br><code>socket</code>的含义就是两个应用程序通过一个双向的通信连接实现数据的交换，连接的一段就是一个<code>socket</code>，又称为套接字。实现一个<code>socket</code>连接通信至少需要两个套接字，一个运行在服务端（插孔），一个运行在客户端（插头）。套接字用于描述<code>IP</code>地址和端口，是一个通信链的句柄。应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是操作系统提供给通信层的一组抽象<code>API</code>接口。<br><code>socket</code>是应用层与<code>TCP/IP</code>协议簇通信的中间抽象层，是一组接口。在设计模式中其实就是门面模式。<code>Socket</code>将复杂的<code>TCP/IP</code>协议簇隐藏在接口后面，对于用户而言，一组接口即可让<code>Socket</code>去组织数据，以符合指定的协议。<br><img src="/images/clickhouse/jdbc/1.png" alt="1"></li>
</ul>
<h3 id="回归正题，什么是Read-Timed-Out"><a href="#回归正题，什么是Read-Timed-Out" class="headerlink" title="回归正题，什么是Read Timed Out"></a>回归正题，什么是Read Timed Out</h3><p>所谓<code>read timed out</code>就是读超时，<code>http</code>连接已创建，客户端等待服务端返回结果，等待时间超过了超时时间，所以客户端连接断开，抛出<code>SocketTimeoutException</code>异常。我们可以模拟出这个过程，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ReadTimedOutTest &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      ServerSocket serverSocket &#x3D; new ServerSocket(8888, 200);</span><br><span class="line">      Thread.sleep(66666666);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void tetReadTimedOut() &#123;</span><br><span class="line">    Socket socket &#x3D; new Socket();</span><br><span class="line">    long starTime &#x3D; 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8888), 10000);</span><br><span class="line">      System.out.println(&quot;socket连接成功。。。。&quot;);</span><br><span class="line">      socket.setSoTimeout(2000);</span><br><span class="line">      starTime &#x3D; System.currentTimeMillis();</span><br><span class="line">      int read &#x3D; socket.getInputStream().read();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">      System.out.println(&quot;执行时间：&quot;+(endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>报错信息如下截图：<br><img src="/images/clickhouse/jdbc/2.png" alt="2"><br>意思是说已连接服务端的8888端口，握手是正常的，然后开始传输数据，因为限制了服务端<code>Thread.sleep</code>，让服务端无法给客户端传输数据</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><code>clickhouse-jdbc</code>默认给<code>SOCKET_TIMEOUT</code>设置的时间是30s，由于服务端不知道何时能返回结果（此时间受<code>settings.max_execution_time</code>影响），所以我们最好给<code>jdbc</code>设置一个<strong>socket_timeout=max_execution_time+10s</strong>，防止服务端还在处理，而客户端已经超时断开连接。<br><img src="/images/clickhouse/jdbc/3.png" alt="3"><br>下面这个方法，主要是解析<strong>jdbc:clickhouse://127.0.0.1:8023?socket_timeout=500000&amp;connection_timeout=500000</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static Properties parseUriQueryPart(String query, Properties defaults) &#123;</span><br><span class="line">  if (query &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return defaults;</span><br><span class="line">  &#125;</span><br><span class="line">  Properties urlProps &#x3D; new Properties(defaults);</span><br><span class="line">  String queryKeyValues[] &#x3D; query.split(&quot;&amp;&quot;);</span><br><span class="line">  for (String keyValue : queryKeyValues) &#123;</span><br><span class="line">      String keyValueTokens[] &#x3D; keyValue.split(&quot;&#x3D;&quot;);</span><br><span class="line">      if (keyValueTokens.length &#x3D;&#x3D; 2) &#123;</span><br><span class="line">          urlProps.put(keyValueTokens[0], keyValueTokens[1]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          logger.warn(&quot;don&#39;t know how to handle parameter pair: &#123;&#125;&quot;, keyValue);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return urlProps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/clickhouse/jdbc/4.png" alt="4"><br><img src="/images/clickhouse/jdbc/5.png" alt="5"></p>
<h3 id="clickhouse-jdbc执行过程"><a href="#clickhouse-jdbc执行过程" class="headerlink" title="clickhouse-jdbc执行过程"></a>clickhouse-jdbc执行过程</h3><h4 id="实例化ClickHouseDataSource对象"><a href="#实例化ClickHouseDataSource对象" class="headerlink" title="实例化ClickHouseDataSource对象"></a>实例化ClickHouseDataSource对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClickHouseDataSource dataSource &#x3D; new ClickHouseDataSource(jdbc, properties);</span><br></pre></td></tr></table></figure>
<p>该构造函数主要是将<strong>jdbc:clickhouse//ip:port/database?key1=value1&amp;key2=value2</strong>这个url进行解析，若涉及clickhouse默认参数，则会覆盖<code>clickhouse</code>默认配置，返回<code>ClickHouseProperties</code>d对象<br><img src="/images/clickhouse/jdbc/6.png" alt="6"></p>
<h4 id="获取ClickHouseConnectionImpl连接"><a href="#获取ClickHouseConnectionImpl连接" class="headerlink" title="获取ClickHouseConnectionImpl连接"></a>获取ClickHouseConnectionImpl连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClickHouseConnectionImpl connection &#x3D; (ClickHouseConnectionImpl) dataSource.getConnection();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1、实例化ClickHouseConnectionImpl对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClickHouseConnectionImpl connection &#x3D; new ClickHouseConnectionImpl(url, properties);</span><br></pre></td></tr></table></figure>
<p><img src="/images/clickhouse/jdbc/7.png" alt="7"><br><img src="/images/clickhouse/jdbc/8.png" alt="8"><br>这里主要是干2件事，1、首先要实例化出<code>ClickHouseHttpClientBuilder</code>客户端对象构造器，这个构造器会把我们在<strong>jdbc:clickhouse//ip:port/database?key1=value1&amp;key2=value2</strong>这个url里的<strong>key1=value1&amp;key2=value2</strong>传入给<code>CloseableHttpClient</code>类型的<code>httpclient</code>，2、再去初始化连接，获取<code>clickhouse</code>服务端的时区和版本，所以我们每次连接<code>clickhouse-jdbc</code>，都会看到发出一条sql<code>select timezone(), version()</code></p>
</li>
<li><p>2、把连接存到<code>Collections.synchronizedMap</code>线程安全的<code>map</code>里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerConnection(connection);</span><br></pre></td></tr></table></figure></li>
<li>3、返回连接对象</li>
</ul>
<h4 id="执行sql过程"><a href="#执行sql过程" class="headerlink" title="执行sql过程"></a>执行sql过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.createStatement().executeQuery(sql);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先初始化<code>ClickHouseStatementImpl</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ClickHouseStatement createStatement(int resultSetType) throws SQLException &#123;</span><br><span class="line">    return LogProxy.wrap(</span><br><span class="line">        ClickHouseStatement.class,</span><br><span class="line">        new ClickHouseStatementImpl(</span><br><span class="line">            httpclient,</span><br><span class="line">            this,</span><br><span class="line">            properties,</span><br><span class="line">            resultSetType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再执行<code>sql</code><br>1、方法<code>getLastInputStream</code>，支持<code>multi-query</code>用法，多条sql去查<br><img src="/images/clickhouse/jdbc/9.png" alt="9"><br>2、调用的<code>getInputStream</code>方法其实就是构造http的post请求，去执行和返回结果，出错则抛出异常<br><img src="/images/clickhouse/jdbc/10.png" alt="10"><br>3、获取最后的执行结果<br><img src="/images/clickhouse/jdbc/11.png" alt="11"><br>4、返回最后sql的结果集<code>ResultSet</code>，select查询类按配置取到最后结果，其他为null</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Read timed out</code>表示已经连接成功(即三次握手已经完成)，但是服务器没有及时返回数据(没有在设定的时间内返回数据)，导致读超时。</li>
<li><code>java</code>在<code>linux</code>中的 <code>Read timed out</code> 并不是通过<code>C</code>函数<code>setSockOpt(SO_RCVTIMEO)</code>来设置的，而是通过<code>select(s, timeout)</code>来实现定时器，并抛出<code>JNI</code>异常来控制的</li>
<li><code>java socket</code>读超时的设置是在<code>read()</code>方法被调用的时候传入的，所以只要在<code>read()</code>调用之前设置即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/17/mysql-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/mysql-lock/" class="post-title-link" itemprop="url">mysql锁相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 12:39:59" itemprop="dateCreated datePublished" datetime="2021-12-17T12:39:59+08:00">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>SpringBoot</code>的<code>schedule</code>模块可以支持定时脚本，原理其实就是<code>SchedulingTaskExecutor</code>类，它实现了<code>java.util.concurrent.Executor</code>接口，这个接口主要是定义了线程的执行，例如我们日常常用的线程池执行器<code>ThreadPoolExecutor</code>类就是实现了<code>Executor</code>接口。此文重点不是介绍<code>SpringBoot</code>的<code>schedule</code>模块，所以具体实现逻辑及源码部分解析，在此略过。但问题是<code>schedule</code>模块不支持分布式部署，而我们当前的业务需要部署在多个节点上，为了实现多个节点上在某个时刻只执行某个定时脚本，其他节点不重复执行，我们调研了<code>MYSQL</code>的锁，用以实现分布式锁场景。</p>
<h3 id="mysql锁"><a href="#mysql锁" class="headerlink" title="mysql锁"></a>mysql锁</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>什么是乐观锁<blockquote>
<p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
</blockquote>
</li>
<li>实现过程<br>假设表结构如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;lock&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(255) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;锁名称&#39;,</span><br><span class="line">  &#96;status&#96; tinyint(4) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;锁状态：0-空闲，1-运行&#39;,</span><br><span class="line">  &#96;version&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;版本&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin;</span><br></pre></td></tr></table></figure>
查询方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,version from lock where id &#x3D; #&#123;id&#125;</span><br></pre></td></tr></table></figure>
加锁更新方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update lock set status &#x3D; 1，version&#x3D;version+1 where id &#x3D; #&#123;id&#125; and version &#x3D; #&#123;version&#125;</span><br></pre></td></tr></table></figure>
释放锁更新方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update lock set status &#x3D; 0 where id &#x3D; #&#123;id&#125; and status &#x3D; 1</span><br></pre></td></tr></table></figure>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4></li>
<li><p>什么是悲观锁</p>
<blockquote>
<p>与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟<code>java</code>中的<code>synchronized</code>很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。<br>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p>
</blockquote>
</li>
<li><p>什么是共享锁</p>
<blockquote>
<p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>
</blockquote>
</li>
</ul>
<p>在查询语句后面增加 <code>LOCK IN SHARE MODE</code> ，<code>Mysql</code>会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。<br>加上共享锁后，对于<code>update</code>，<code>insert</code>，<code>delete</code>语句会自动加排它锁。</p>
<p>举例说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在A窗口输入</span><br><span class="line">select * from lock where id &#x3D; 1 lock in shard mode</span><br><span class="line"># 在B窗口输入</span><br><span class="line">update lock set version &#x3D; version + 1 where id &#x3D; 1</span><br><span class="line"># B窗口报错</span><br><span class="line">[Err] 1205 - Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure></p>
<ul>
<li>什么是排它锁<blockquote>
<p>排他锁 exclusive lock（也叫writer lock）又称写锁。<br>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。<br>若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁</p>
</blockquote>
</li>
</ul>
<p>举例说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 要使用排他锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交</span><br><span class="line"># 在A窗口输入</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">begin;</span><br><span class="line">select * from lock where id &#x3D; 1 for update;</span><br><span class="line">update lock set version &#x3D; version + 1 where id &#x3D; 1;</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># 在B窗口输入，会看到一直在等待中,直到A窗口释放锁,B窗口才能获取结果</span><br><span class="line">select * from lock where id &#x3D; 1 for update;</span><br></pre></td></tr></table></figure></p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><code>InnoDB</code>的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。<br>行锁的劣势：开销大；加锁慢；会出现死锁<br>行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强<br>加锁的方式：自动加锁。对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁；对于普通<code>SELECT</code>语句，<code>InnoDB</code>不会加任何锁；当然我们也可以显示的加锁</p>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，<code>InnoDB</code>也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（<code>Next-Key</code>锁）<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁</span><br><span class="line"># InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</span><br><span class="line"># 指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了</span><br><span class="line">Select * from  emp where empid &gt; 100 for update;</span><br></pre></td></tr></table></figure>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>在<code>Innodb</code>引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候只锁住一行呢？ 只有通过<strong>索引条件</strong>检索数据，<code>InnoDB</code>才使用行级锁，否则，<code>InnoDB</code>将使用表锁，而检索条件是<code>unique key</code>、<code>primary key</code>时，一定会是<strong>行锁</strong>，而检索条件是<code>index</code>时，有可能是行锁 ，也有可能是表锁，取决于当“值重复率”低时，甚至接近主键或者唯一索引的效果，“普通索引”依然是行锁；当“值重复率”高时，<code>MySQL</code> 不会把这个“普通索引”当做索引，即造成了一个没有索引的 SQL，此时引发表锁</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁（Deadlock）是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。<br>解除正在死锁的状态有两种方法：<br>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询是否锁表</span><br><span class="line">show OPEN TABLES where In_use &gt; 0;</span><br><span class="line"># 查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</span><br><span class="line">show processlist</span><br><span class="line"># 杀死进程id（就是上面命令的id列）</span><br><span class="line">kill id</span><br></pre></td></tr></table></figure></p>
<p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前的事务</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"># 查看当前锁定的事务</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line"># 查看当前等锁的事务</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br><span class="line"># 杀死进程</span><br><span class="line">kill 进程ID</span><br></pre></td></tr></table></figure></p>
<h3 id="MYISAM引擎-和-INNODB引擎的区别"><a href="#MYISAM引擎-和-INNODB引擎的区别" class="headerlink" title="MYISAM引擎 和 INNODB引擎的区别"></a>MYISAM引擎 和 INNODB引擎的区别</h3><h4 id="MYISAM-读锁"><a href="#MYISAM-读锁" class="headerlink" title="MYISAM 读锁"></a>MYISAM 读锁</h4><p>读锁 影响其他进程对该表进行写操作，但不影响其他进程对该表进行读操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock myisam_table read;</span><br><span class="line">select * from myisam_table where id &#x3D; 1;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<h4 id="MYISAM-写锁"><a href="#MYISAM-写锁" class="headerlink" title="MYISAM 写锁"></a>MYISAM 写锁</h4><p>写锁 影响其他进程对该表进行读和写操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock myisam_table write;</span><br><span class="line">select * from myisam_table where id &#x3D; 1;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><br>在自动加锁的情况下也基本如此，<code>MyISAM</code> 总是一次获得 <code>SQL</code> 语句所需要的全部锁。这也正是 <code>MyISAM</code> 表不会出现死锁(<code>Deadlock Free</code>)的原因</p>
<ul>
<li><code>InnoDB</code>支持事务(<code>transaction</code>)；<code>MyISAM</code>不支持事务</li>
<li><code>Innodb</code> 默认采用行锁， <code>MyISAM</code> 是默认采用表锁。加锁可以保证事务的一致性，可谓是有人(锁)的地方，就有江湖(事务)</li>
<li><code>MyISAM</code>不适合高并发（MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁）<blockquote>
<p>MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当concurrent_insert设置为0时,不允许并发插入。</span><br><span class="line">当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的 行),MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL 的默认设置。</span><br><span class="line">当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>我们采用<strong>乐观锁</strong> 来处理这次的定时任务多节点执行时分布式锁方案</p>
<ul>
<li><p>表结构设计</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;job_lock&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(255) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;job名称&#39;,</span><br><span class="line">  &#96;timeout&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;任务执行超时间隔,毫秒&#39;,</span><br><span class="line">  &#96;status&#96; tinyint(4) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;job状态：0-空闲，1-运行&#39;,</span><br><span class="line">  &#96;description&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;job描述&#39;,</span><br><span class="line">  &#96;gmt_create&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_update&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;version&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;版本&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加锁方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;requireLock&quot; parameterType&#x3D;&quot;java.util.Map&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">    update job_lock</span><br><span class="line">    set status &#x3D; 1, version&#x3D;version + 1</span><br><span class="line">    where id &#x3D; #&#123;id&#125; and version &#x3D;#&#123;version&#125; and status &#x3D; 0</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;releaseLock&quot; parameterType&#x3D;&quot;java.util.Map&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">    update job_lock</span><br><span class="line">    set status &#x3D; 0</span><br><span class="line">    where id &#x3D; #&#123;id&#125; and status &#x3D; 1</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public JobLockDO tryLock(String name) &#123;</span><br><span class="line">  if (ValidateUtils.isNull(name))&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  JobLockDO jobLocksDO &#x3D; getJob(name);</span><br><span class="line">  if (ValidateUtils.isNull(jobLocksDO)) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 任务一直在运行中，可能是服务重启等异常情况，造成锁状态一直未更新</span><br><span class="line">  if (jobLocksDO.getStatus().equals(Constant.JOB_LOCK_RUNNING)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先判断运行是否超时，未超时，则不处理</span><br><span class="line">    if (System.currentTimeMillis() - jobLocksDO.getGmtUpdate().getTime() &lt;&#x3D; jobLocksDO.getTimeout()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 已超时，更新任务锁状态(释放锁)</span><br><span class="line">      releaseLock(jobLocksDO.getId());</span><br><span class="line">      &#x2F;&#x2F; 重新加锁</span><br><span class="line">      requireLock(jobLocksDO.getId(), jobLocksDO.getVersion());</span><br><span class="line">      &#x2F;&#x2F; 返回任务锁</span><br><span class="line">      return jobLocksDO;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 加锁</span><br><span class="line">    if (!requireLock(jobLocksDO.getId(), jobLocksDO.getVersion())) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return jobLocksDO;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(&quot;require lock by name:&#123;&#125; fail.&quot;, name, e);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/11/clickhouse-user-quota/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/11/clickhouse-user-quota/" class="post-title-link" itemprop="url">ClickHouse用户资源隔离在滴滴的实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-11 18:09:40" itemprop="dateCreated datePublished" datetime="2021-12-11T18:09:40+08:00">2021-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>大数据架构<code>olap</code>团队对<code>clickhouse</code>的使用是从2019年5月开始，最开始我们只在国内永顺机房落地了4台机器做共享集群，就是最开始的<code>cluster01</code>集群，4台机器做2个<code>shard</code>，每个<code>shard</code>2个<code>replica</code>，而用户对集群的访问只是通过一个<code>vip</code>做简单的负载均衡，关于权限这一块，我们在当时只做到了库级别的管控，简单说就是通过同步<code>dpp_v3</code>.<code>hadoop_account</code>和<code>dpp_v3</code>.<code>hive_database</code>库去更新<code>user.xml</code>文件，如下图所示，我们并未对租户资源做任何隔离，虽然最开始我们就是使用的多租户模型，但每个租户可以有权限去操作自己名下的所有库，包括读和写，且无限制的进行大量耗资源（<code>cpu</code>和<code>memory</code>）写入和查询后就会影响到<code>cluster01</code>集群下其他的租户，因为<code>cpu</code>和<code>memory</code>是固定的，而租户的分摊并未做限制。<br><img src="/images/clickhouse/authority/2.png" alt="avatar"></p>
<h3 id="clickhouse配置详解"><a href="#clickhouse配置详解" class="headerlink" title="clickhouse配置详解"></a>clickhouse配置详解</h3><h4 id="config-xml文件介绍"><a href="#config-xml文件介绍" class="headerlink" title="config.xml文件介绍"></a>config.xml文件介绍</h4><p><code>clickhouse</code>的启动方式是通过以下命令处理的，就让 <code>ClickHouse</code> 按照<code>config.xml</code>配置文件运行，同时 <code>ClickHouse</code> 监听配置文件，如有变化，不需要重启就能按新的配置运行。具体介绍可以参考<a href="https://clickhouse.com/docs/en/operations/configuration-files/#implementation-details" target="_blank" rel="noopener">链接</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;clickhouse-server --config&#x3D;.&#x2F;conf&#x2F;config.xml</span><br></pre></td></tr></table></figure><br>我们在生产环境下<code>config.xml</code>文件主要是如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;yandex&gt; </span><br><span class="line">    &lt;!-- 日志配置 --&gt;</span><br><span class="line">    &lt;logger&gt; </span><br><span class="line">        &lt;level&gt;trace&lt;&#x2F;level&gt; </span><br><span class="line">        &lt;log&gt;&#x2F;tmp&#x2F;log&#x2F;clickhouse-server.log&lt;&#x2F;log&gt; </span><br><span class="line">        &lt;errorlog&gt;&#x2F;tmp&#x2F;log&#x2F;clickhouse-server.err.log&lt;&#x2F;errorlog&gt; </span><br><span class="line">        &lt;size&gt;1000M&lt;&#x2F;size&gt; </span><br><span class="line">        &lt;count&gt;10&lt;&#x2F;count&gt; </span><br><span class="line">    &lt;&#x2F;logger&gt; </span><br><span class="line">    &lt;!-- 开启查询和写入相关日志配置 --&gt;</span><br><span class="line">    &lt;query_log&gt; </span><br><span class="line">        &lt;database&gt;system&lt;&#x2F;database&gt; </span><br><span class="line">        &lt;table&gt;query_log&lt;&#x2F;table&gt; </span><br><span class="line">        &lt;partition_by&gt;toYYYYMM(event_date)&lt;&#x2F;partition_by&gt; </span><br><span class="line">        &lt;flush_interval_milliseconds&gt;1000&lt;&#x2F;flush_interval_milliseconds&gt; </span><br><span class="line">    &lt;&#x2F;query_log&gt; </span><br><span class="line">    &lt;!-- tcp端口 --&gt;</span><br><span class="line">    &lt;tcp_port&gt;9000&lt;&#x2F;tcp_port&gt; </span><br><span class="line">    &lt;!-- 运行所有ip访问 --&gt;</span><br><span class="line">    &lt;listen_host&gt;0.0.0.0&lt;&#x2F;listen_host&gt; </span><br><span class="line">    &lt;!-- 最大连接数 --&gt;</span><br><span class="line">    &lt;max_connections&gt;4096&lt;&#x2F;max_connections&gt;</span><br><span class="line">    &lt;!-- 连接超时时间 --&gt;</span><br><span class="line">    &lt;keep_alive_timeout&gt;90&lt;&#x2F;keep_alive_timeout&gt;</span><br><span class="line">    &lt;!-- 最大并发查询数 --&gt;</span><br><span class="line">    &lt;max_concurrent_queries&gt;1000&lt;&#x2F;max_concurrent_queries&gt;</span><br><span class="line">    &lt;!-- 用户配置文件 --&gt;</span><br><span class="line">    &lt;users_config&gt;users.xml&lt;&#x2F;users_config&gt;</span><br><span class="line">    &lt;!-- 默认配置名称 --&gt;</span><br><span class="line">    &lt;default_profile&gt;default&lt;&#x2F;default_profile&gt;</span><br><span class="line">    &lt;!-- 默认数据库名称 --&gt;</span><br><span class="line">    &lt;default_database&gt;default&lt;&#x2F;default_database&gt;</span><br><span class="line">    &lt;!-- zookeeper配置 --&gt;</span><br><span class="line">    &lt;zookeeper incl&#x3D;&quot;zookeeper-servers&quot; optional&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 宏配置 --&gt;</span><br><span class="line">    &lt;macros incl&#x3D;&quot;macros&quot; optional&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 权限相关的sql存储路径 --&gt;</span><br><span class="line">    &lt;access_control_path&gt;&#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;access&lt;&#x2F;access_control_path&gt;</span><br><span class="line">&lt;&#x2F;yandex&gt;</span><br></pre></td></tr></table></figure><br>我们应该注意到 <code>&lt;users_config&gt;users.xml&lt;/users_config&gt;</code> 绑定了 <code>config.xml</code> 当前目录的 <code>users.xml</code>,而 <code>users.xml</code>就是我们最初版本的用户配置文件</p>
<h4 id="users-xml文件介绍"><a href="#users-xml文件介绍" class="headerlink" title="users.xml文件介绍"></a>users.xml文件介绍</h4><p><code>ClickHouse</code>支持基于 <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="noopener">RBAC</a>（基于角色的访问控制权限）方法的访问控制管理。作为一个分析类型（<code>OLAP</code>）的数据库系统，相对于<code>MySQL</code>数据库在用户管理方面有很大不同，<code>clickhouse</code>支持使用两种方式配置访问实体：</p>
<ul>
<li>通过<code>sql</code>直接设置，这也是官方推荐的，但是需要至少一个用户帐户启用<code>SQL</code>驱动的访问控制和帐户管理，这需要使用第二种方式设置<code>access_management</code></li>
<li>通过配置文件<code>users.xml</code>，默认位置在<code>/etc/clickhouse-server</code>目录下，<code>ClickHouse</code>使用它来定义用户相关的配置项。<blockquote>
<p>注意，您不能同时通过两种配置方法来管理同一访问实体。（You can’t manage the same access entity by both configuration methods simultaneously.）<br><code>users.xml</code>有三大块进行说明，分别为：<code>profiles</code>，<code>quotas</code>，<code>users</code>，主要配置如下所示：</p>
</blockquote>
</li>
<li>profiles介绍<br><a href="https://clickhouse.com/docs/en/operations/settings/settings-profiles/" target="_blank" rel="noopener">官方链接</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- profiles相当于role角色配置 --&gt;</span><br><span class="line">&lt;profiles&gt; </span><br><span class="line">    &lt;!-- 角色名称，可配置多个 --&gt;</span><br><span class="line">    &lt;default&gt; </span><br><span class="line">        &lt;!-- 单个服务器 最大可使用内存 --&gt;</span><br><span class="line">        &lt;max_memory_usage&gt;10G&lt;&#x2F;max_memory_usage&gt; </span><br><span class="line">        &lt;!-- 单个服务器 用户查询最大可使用内存 --&gt;</span><br><span class="line">        &lt;max_memory_usage_for_user&gt;10G&lt;&#x2F;max_memory_usage_for_user&gt; </span><br><span class="line">        &lt;!-- 所有查询可使用的最大内存 --&gt;</span><br><span class="line">        &lt;max_memory_usage_for_all_queries&gt;10G&lt;&#x2F;max_memory_usage_for_all_queries&gt; </span><br><span class="line">        &lt;!-- 最大查询长度 --&gt;</span><br><span class="line">        &lt;max_query_size&gt;1073741824&lt;&#x2F;max_query_size&gt; </span><br><span class="line">        &lt;!-- DDL查询：CREATE，ALTER，RENAME，ATTACH，DETACH，DROP TRUNCATE,0:禁止，1:允许 --&gt;</span><br><span class="line">        &lt;allow_ddl&gt;0&lt;&#x2F;allow_ddl&gt;</span><br><span class="line">    &lt;&#x2F;default&gt; </span><br><span class="line">    &lt;readonly&gt;</span><br><span class="line">      &lt;!-- 只读角色，枚举0:允许所有查询，1:只允许读数据的查询，3:运行读取数据和更改配置 --&gt;</span><br><span class="line">      &lt;readonly&gt;2&lt;&#x2F;readonly&gt;</span><br><span class="line">    &lt;&#x2F;readonly&gt;</span><br><span class="line">&lt;&#x2F;profiles&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>quotas介绍<br><a href="https://clickhouse.com/docs/en/operations/quotas/" target="_blank" rel="noopener">官方链接</a>，截取部分代码实现细节如下,从源码中我们能看出，每次查询的时候，都去检查(<code>checkExceeded()</code>)是否超过配额<br><img src="/images/clickhouse/authority/3.png" alt="avatar">，每个 interval 都有多种资源(<code>resource_type</code>), 比如 <code>`&lt;query&gt;1&lt;/query&gt;</code> 是一种 <code>type</code>, 检查最大库存 <code>max</code>，检查已经使用的配额 <code>used</code>, 如果 <code>used</code> &gt; <code>max</code>, 则报错。<br><img src="/images/clickhouse/authority/4.png" alt="avatar"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配额，限制用户一段时间内的资源使用，即对一段时间内运行的一组查询施加限制，而不是限制单个查询。 --&gt;</span><br><span class="line">&lt;quotas&gt; </span><br><span class="line">    &lt;!-- 配额名称 --&gt;</span><br><span class="line">    &lt;default&gt; </span><br><span class="line">        &lt;!-- 时间间隔 --&gt;</span><br><span class="line">        &lt;interval&gt; </span><br><span class="line">            &lt;!-- 时间周期 以秒为单位 --&gt; </span><br><span class="line">            &lt;duration&gt;10&lt;&#x2F;duration&gt; </span><br><span class="line">            &lt;!-- 10 秒内只能查询一次 --&gt; </span><br><span class="line">            &lt;queries&gt;2&lt;&#x2F;queries&gt; </span><br><span class="line">            &lt;errors&gt;0&lt;&#x2F;errors&gt; </span><br><span class="line">            &lt;!-- 时间周期内允许返回的行数，0表示不限制 --&gt;</span><br><span class="line">            &lt;result_rows&gt;0&lt;&#x2F;result_rows&gt; </span><br><span class="line">            &lt;!-- 时间周期内运行读取的行数，0表示不限制 --&gt;</span><br><span class="line">            &lt;read_rows&gt;0&lt;&#x2F;read_rows&gt; </span><br><span class="line">            &lt;!-- 时间周期内查询的可执行时间，0表示不限制 --&gt;</span><br><span class="line">            &lt;execution_time&gt;0&lt;&#x2F;execution_time&gt; </span><br><span class="line">        &lt;&#x2F;interval&gt;</span><br><span class="line">    &lt;&#x2F;default&gt; </span><br><span class="line">&lt;&#x2F;quotas&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>users介绍<br><a href="https://clickhouse.com/docs/en/operations/quotas/" target="_blank" rel="noopener">官方链接</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用户配置,定义一个新用户，必须包含以下几项属性：用户名、密码、访问ip、数据库、表等等。它还可以应用上面的profile、quota --&gt;</span><br><span class="line">&lt;users&gt; </span><br><span class="line">    &lt;!-- 用户名 --&gt;</span><br><span class="line">    &lt;default&gt; </span><br><span class="line">        &lt;!-- 此设置为用户启用或禁用SQL驱动的访问控制和帐户管理。可能的值：0-禁用。1-启用。默认为0 --&gt;</span><br><span class="line">        &lt;access_management&gt;1&lt;&#x2F;access_management&gt;</span><br><span class="line">        &lt;!-- 密码 --&gt;</span><br><span class="line">        &lt;password&gt;password&lt;&#x2F;password&gt; </span><br><span class="line">        &lt;!-- 用户可以从中连接到ClickHouse服务器的网络列表 --&gt;</span><br><span class="line">        &lt;networks&gt; </span><br><span class="line">            &lt;!-- 要为来自任何网络的用户打开访问权限 --&gt;</span><br><span class="line">            &lt;ip&gt;::&#x2F;0&lt;&#x2F;ip&gt; </span><br><span class="line">        &lt;&#x2F;networks&gt; </span><br><span class="line">        &lt;!-- 指定用户的角色 --&gt;</span><br><span class="line">        &lt;profile&gt;default&lt;&#x2F;profile&gt; </span><br><span class="line">        &lt;!-- 指定用户的配额 --&gt;</span><br><span class="line">        &lt;quota&gt;default&lt;&#x2F;quota&gt; </span><br><span class="line">    &lt;&#x2F;default&gt; </span><br><span class="line">&lt;&#x2F;users&gt;</span><br></pre></td></tr></table></figure>
<h4 id="常见的权限报错"><a href="#常见的权限报错" class="headerlink" title="常见的权限报错"></a>常见的权限报错</h4></li>
<li>超过quota限制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code: 201. DB::Exception: Received from localhost:9000. DB::Exception: Quota for user &#96;default&#96; for 10s has been exceeded: queries &#x3D; 4&#x2F;3. Interval will end at 2020-04-02 11:29:40. Name of quota template: &#96;default&#96;.</span><br></pre></td></tr></table></figure>
如果在至少一个时间间隔内超过了限制，则将引发一个异常，并显示一条文本：是对于哪一个间隔的，何时新间隔可以开始（何时可以再次发送查询）。</li>
<li>超过profile限制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code: 452, e.displayText() &#x3D; DB::Exception: Setting max_memory_usage should not be greater than 20000000000.</span><br><span class="line">Code: 452, e.displayText() &#x3D; DB::Exception: Setting max_memory_usage should not be less than 5000000000.</span><br></pre></td></tr></table></figure>
查询超过了最大使用内存</li>
<li>user限制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code: 516, e.displayText() &#x3D; DB::Exception: prod_dlap_manager: Authentication failed: password is incorrect or there is no user with such name (version 206.1.1)</span><br></pre></td></tr></table></figure>
用户不存在，或者用户的密码错误<h3 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h3>经过对<code>clickhouse</code>的权限相关了解之后，我们在2021年8月进行了一次权限升级方案改造，通过default用户创建出超级管理员super_admin及普通管理员admin（如果在user.xml里定义了super_admin用户，之后就无法修改，若修改则直接报错<code>Cannot update user admin in users.xml because this storage is readonly</code>），以超级管理员的身份给超级租户和普通租户赋权，可以通过SQL的方式进行权限的<code>CRUD</code>，以达到动态分配集群资源的目的。<br><img src="/images/clickhouse/authority/5.png" alt="avatar"><br>经过拆分后，我们单独自研了<code>DlapManager</code>组件，用以管控<code>Clickhouse</code>集群读写节点、<code>zookeeper</code>组件、<code>CHProxy</code>组件（采用开源工具快速接入以实现读写ck角色的区分，达到数据写入均衡查询均衡的 目的，<a href="https://github.com/Vertamedia/chproxy" target="_blank" rel="noopener">链接</a>），而<code>CHProxy</code>组件需要的集群读写资源则通过<code>DlapManager</code>角色进行实时更新和生产，而外部平台业务方直接调用<code>DlapManager</code>组件对外开放的<code>api</code>进行库表的所有<code>DDL</code>操作，目前我们的所有普通租户均是用户通过数据梦工厂的创建项目开通实时权限后，我们会自动创建一个租户在<code>Clickhouse</code>这边，当该租户进行库表<code>DDL</code>后，<code>DlapManager</code>组件就会生成相应的<code>DDL</code>任务队列，队列以异步线程方式实时发往对应的集群，以下的<code>DlapManager</code>组件的系统架构设计图：<br><img src="/images/clickhouse/authority/6.png" alt="avatar"><h3 id="赋权过程"><a href="#赋权过程" class="headerlink" title="赋权过程"></a>赋权过程</h3>按照<a href="https://clickhouse.com/docs/en/operations/access-rights/#enabling-access-control" target="_blank" rel="noopener">官方推荐</a>的方式进行赋权过程，以达到不同租户使用相应的配额，实现集群内的资源隔离，保障集群的稳定性。</li>
<li>创建超级租户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER super_admin; </span><br><span class="line">GRANT ALL ON *.* TO super_admin WITH GRANT OPTION; </span><br><span class="line">CREATE USER admin;</span><br></pre></td></tr></table></figure></li>
<li>创建profiles设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SETTINGS PROFILE IF NOT EXISTS didi_profile SETTINGS readonly &#x3D; 2 READONLY</span><br></pre></td></tr></table></figure></li>
<li>创建quota配额<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE QUOTA IF NOT EXISTS didi_quota </span><br><span class="line">FOR INTERVAL 10 second </span><br><span class="line">MAX queries 1</span><br></pre></td></tr></table></figure></li>
<li>创建角色<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE IF NOT EXISTS didi_role</span><br></pre></td></tr></table></figure></li>
<li>赋予 Role 权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 允许didi_role这个角色可以访问库名叫db的所有表的查询权限</span><br><span class="line">GRANT SELECT ON db.* TO didi_role</span><br></pre></td></tr></table></figure></li>
<li>创建一个回收角色，用以回收不使用的profile、quota<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REATE ROLE IF NOT EXISTS gc_role</span><br></pre></td></tr></table></figure></li>
<li>Role 绑定 Profile, Quota<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER SETTINGS PROFILE didi_profile TO didi_role;</span><br><span class="line">ALTER QUOTA didi_quota TO didi_role;</span><br></pre></td></tr></table></figure></li>
<li>应用到租户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT didi_role TO super_admin</span><br></pre></td></tr></table></figure></li>
<li>验证租户角色<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM system.role_grants WHERE user_name LIKE &#39;admin&#39;</span><br></pre></td></tr></table></figure></li>
<li>修改用户的quota(当用户的读/写超过了限额后需要给用户扩容)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先创建新quota</span><br><span class="line">CREATE QUOTA IF NOT EXISTS new_quota FOR INTERVAL 5 second MAX queries 1;</span><br><span class="line"># 将原先的didi_quota绑定到gc_role</span><br><span class="line">ALTER QUOTA didi_quota TO gc_role;</span><br><span class="line"># 绑定新quota</span><br><span class="line">ALTER QUOTA new_quota TO didi_role; </span><br><span class="line"># 刷新admin的角色</span><br><span class="line">revoke didi_role from admin; </span><br><span class="line">grant didi_role to admin;</span><br><span class="line"># double check检查</span><br><span class="line">SELECT name, apply_to_list FROM system.quotas WHERE name LIKE &#39;new_quota&#39;</span><br></pre></td></tr></table></figure></li>
<li>修改用户的profile(当用户的读/写超过了限额后需要给用户扩容)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先创建新profile</span><br><span class="line">CREATE SETTINGS PROFILE IF NOT EXISTS new_profile SETTINGS readonly &#x3D; 0 READONLY;</span><br><span class="line"># 将原先的didi_profile绑定到gc_role</span><br><span class="line">ALTER SETTINGS PROFILE didi_profile TO gc_role</span><br><span class="line"># 绑定新profile</span><br><span class="line">ALTER SETTINGS PROFILE new_profile TO didi_role;</span><br><span class="line"># 刷新admin的角色</span><br><span class="line">revoke didi_role from admin; </span><br><span class="line">grant didi_role to admin;</span><br><span class="line"># double check检查</span><br><span class="line">SELECT name, apply_to_list FROM system.settings_profiles WHERE name LIKE &#39;new_quota&#39;</span><br></pre></td></tr></table></figure>
<h3 id="权限持久化"><a href="#权限持久化" class="headerlink" title="权限持久化"></a>权限持久化</h3></li>
<li>存放目录配置<br>根据<a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#access_control_path" target="_blank" rel="noopener">官方文档</a>介绍，通过<code>sql</code>进行的权限相关配置，可以通过<code>config.xml</code>里的<code>access_control_path</code>属性进行路径配置，若未配置则默认是<code>/var/lib/clickhouse/access/</code>目录，如下图所示，当<code>clickhouse</code>重启后，都会先从<code>access_control_path</code>配置的目录里根据<code>sql</code>恢复所有权限，如果这些文件被删除，则重启<code>clickhouse</code>后之前通过<code>sql</code>创建的这些<code>setting</code>都会消失，所以注意文件的备份，目前<code>DlapManager</code>组件是使用<code>mysql</code>数据存储引擎单独存储了这份<code>RBAC</code>数据，再发送给<code>clickhouse</code>进行权限相关的<code>CRUD</code>，这个方式也相当于是<code>clickhouse</code>的备份地址，如果<code>clickhouse</code>重启后无法刷新这些权限，则仍然可以通过<code>DlapManager</code>组件写的脚本工具去重新生产出新的<code>sql</code>给<code>clickhouse</code>使用。<br><img src="/images/clickhouse/authority/7.png" alt="avatar"></li>
<li>users.list介绍<br>每创建一个用户，则会在<code>users.list</code>文件里记录到用户名对应的一串<code>uuid</code>，可通过<code>uuid</code>找到创建该用户的<code>sql</code>语句，如下图：<br><img src="/images/clickhouse/authority/8.png" alt="avatar"></li>
<li>uuid.sql介绍<br>包含了创建用户（create user）的sql，赋权（GRANT）的sql等<br><img src="/images/clickhouse/authority/9.png" alt="avatar"></li>
<li>quotas.list介绍<br>每创建一个<code>quota</code>，都会在<code>quotas.list</code>文件记录quota名称及对应的一个<code>uuid</code>，可通过<code>uuid</code>找到创建该<code>quota</code>的<code>sql</code>语句</li>
<li>roles.list介绍<br>每创建一个<code>role</code>，都会在<code>roles.list</code>文件记录quota名称及对应的一个<code>uuid</code>，可通过<code>uuid</code>找到创建该<code>role</code>的<code>sql</code>语句</li>
<li>row_policies.list介绍<br>每创建一个<code>row_policy</code>，都会在<code>row_policies.list</code>文件记录quota名称及对应的一个<code>uuid</code>，可通过<code>uuid</code>找到创建该<code>row_policy</code>的<code>sql</code>语句</li>
<li>settings_profiles.list介绍<br>每创建一个<code>profile</code>，都会在<code>settings_profiles.list</code>文件记录quota名称及对应的一个<code>uuid</code>，可通过<code>uuid</code>找到创建该<code>profile</code>的<code>sql</code>语句<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3>本文从<code>clickhouse</code>的用户资源角度来简单介绍了<code>clickhouse</code>的相关配置及如何使用，而我们自研的<code>DlapManager</code>组件则承担起了 <code>ClickHouse</code> 用户管理的角色，通过对<code>clickhouse</code>的<code>profle</code>、<code>quota</code>、<code>role</code>等抽象层的配置来达到对<code>clickhouse</code>使用资源的租户隔离目的，中心思想是我们不是直接给租户赋予相关权限，而是在租户之上创建了角色的维度，和<code>RBAC</code>思想一致，可以达到对租户进行灵活的扩缩容配额，最终来保障我们目前200+<code>clickhouse</code>节点的稳定性。最后笔者从2019年6月开始接触<code>clickhouse</code>，到现在也已经2年+的时间，但仍然只学到了<code>clickhouse</code>的冰山一角，所以以上文字也只能做到抛砖引玉，但仍然希望对阅读的各位有所帮助。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/29/jvm-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/29/jvm-interview/" class="post-title-link" itemprop="url">jvm面试常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-29 14:09:55" itemprop="dateCreated datePublished" datetime="2021-10-29T14:09:55+08:00">2021-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>jvm参数设置说明<br><img src="/images/java_interview/1.png" alt="avatar"></p>
</li>
<li><p>并行收集器相关参数<br><img src="/images/java_interview/2.png" alt="avatar"></p>
</li>
<li><p>JVM CMS相关参数<br><img src="/images/java_interview/3.png" alt="avatar"></p>
</li>
<li><p>JVM辅助信息参数设置<br><img src="/images/java_interview/4.png" alt="avatar"></p>
</li>
<li><p>java进程启动时，未指定最大堆大小和默认初始值时，系统如何分配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\ 直接启动，jvm的那些参数是如何分配的</span><br><span class="line">java xx.jar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先可以通过jinfo -flags pid查看jvm参数，可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:CICompilerCount&#x3D;15 </span><br><span class="line">-XX:InitialHeapSize&#x3D;2147483648 </span><br><span class="line">-XX:MaxHeapSize&#x3D;32210157568 </span><br><span class="line">-XX:MaxNewSize&#x3D;10736369664 </span><br><span class="line">-XX:MinHeapDeltaBytes&#x3D;524288 </span><br><span class="line">-XX:NewSize&#x3D;715653120 </span><br><span class="line">-XX:OldSize&#x3D;1431830528 </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:+UseFastUnorderedTimeStamps </span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
<p>知道答案是<code>-XX:InitialHeapSize=2147483648</code>和<code>-XX:MaxHeapSize=32210157568</code>。另外通过 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size" target="_blank" rel="noopener">jvm默认配置</a>发现这一段<code>Server JVM Default Initial and Maximum Heap Sizes
The default initial and maximum heap sizes work similarly on the server JVM as it does on the client JVM, except that the default values can go higher. On 32-bit JVMs, the default maximum heap size can be up to 1 GB if there is 4 GB or more of physical memory. On 64-bit JVMs, the default maximum heap size can be up to 32 GB if there is 128 GB or more of physical memory. You can always set a higher or lower initial and maximum heap by specifying those values directly; see the next section.</code>中文意思就是32位系统默认最大值可以到1GB，如果物理内存大于或者等于4GB，而在64位系统默认最大堆内存可以达到32GB或者更多，如果物理内存大袋128GB或者更多时。<br>但是要注意过多的</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>JVM GC垃圾回收器参数设置<br>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。<br>默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。<br>串行收集器<br>-XX:+UseSerialGC：设置串行收集器。<br>并行收集器（吞吐量优先）<br>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。<br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。<br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。<br>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。<br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。<br>并发收集器（响应时间优先）<br>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。<br>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。<br>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。<br>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。<br>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。<br>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。<br>其它垃圾回收参数<br>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。<br>-XX:-DisableExplicitGC：不响应 System.gc() 代码。<br>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。<br>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。<br>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</p>
</li>
<li><p>JVM参数疑问解答<br>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？<br>如下：<br>高优先级：-XX:NewSize/-XX:MaxNewSize<br>中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?）<br>低优先级：-XX:NewRatio<br>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。<br>-Xmn参数是在JDK 1.4 开始支持。</p>
</li>
<li><p>JVM参数设置优化例子</p>
</li>
</ul>
<ol>
<li>承受海量访问的动态Web应用<br>服务器配置：8 CPU, 8G MEM, JDK 1.6.X<br>参数方案：<br>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC<br>调优说明：<br>-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。<br>-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。<br>-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。<br>-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。<br>-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。<br>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。<br>-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</li>
<li>内部集成构建服务器案例<br>高性能数据处理的工具应用<br>服务器配置：1 CPU, 4G MEM, JDK 1.6.X<br>参数方案：<br>-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m<br>调优说明：<br>-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。<br>-Xmn320m 遵循年轻代大小为整个堆的3/8原则。<br>-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/22/time-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/time-review/" class="post-title-link" itemprop="url">关于时间的思考和总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 16:09:55" itemprop="dateCreated datePublished" datetime="2021-10-22T16:09:55+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="关于时间的解释"><a href="#关于时间的解释" class="headerlink" title="关于时间的解释"></a>关于时间的解释</h2><h3 id="GMT时间"><a href="#GMT时间" class="headerlink" title="GMT时间"></a>GMT时间</h3><p>格林尼治平时(Greenwich Mean Time，GMT)，又称为格林尼治标准时间。<br>格林尼治平时的正午是指当平太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被原子钟报时的协调世界时（UTC）所取代。</p>
<h3 id="UT时间"><a href="#UT时间" class="headerlink" title="UT时间"></a>UT时间</h3><p>世界时(Universal Time，UT)，是一种以格林尼治子夜起算的平太阳时。<br>由于1925年以前人们在天文观测中，常常把每天的起始（0时）定为正午，而不是通常民用的午夜，给格林尼治平时的意义造成含糊，人们使用世界时一词来明确表示每天从午夜开始的格林尼治平时。</p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>时区是指地球上的某一个区域使用同一个时间定义。GMT时间或者UT时间，都是表示地球自转速率的一种形式。从太阳升起到太阳落下，时刻从0到24变化。这样，不同经度的地方时间自然会不相同。为了解决这个问题，人们把地球按经度划分为不同的区域，每个区域内使用同一个时间定义，相邻的区域时间差为1个小时。时区又分为理论时区和法定时区。</p>
<h3 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h3><p>协调世界时(Coordinated Universal Time)。是主要的世界时间标准，以原子钟所定义的秒长为基础，在时刻上尽量接近GMT时间。UTC时间认为一个太阳日总是86400秒。在大多数情况下，UTC时间能与GMT时间互换。</p>
<h4 id="UTC与时区"><a href="#UTC与时区" class="headerlink" title="UTC与时区"></a>UTC与时区</h4><p>本初子午线所在的时区的时间后面加上字符Z，表示UTC时间。Z即为0时区的标志，读做Zulu。例如09:30 UTC就写作0930Z，14:45:15 UTC则为14:45:15Z或144515Z</p>
<h4 id="UTC偏移量"><a href="#UTC偏移量" class="headerlink" title="UTC偏移量"></a>UTC偏移量</h4><p>UTC偏移量用以下形式表示: ±[hh]:[mm]、±[hh][mm]、或者±[hh]。例如UTC时间为09:30z，此时北京时间就是1730 +0800，纽约时间是0430 -0500。<br>UTC时间表示的格式一般为Sat, 20 May 2018 12:45:57 +0800表示东八区(北京时间)2018年5月20号 12:45:57星期六。</p>
<h4 id="时差"><a href="#时差" class="headerlink" title="时差"></a>时差</h4><p>某个地方的时刻与0时区的时刻差称为时差，时差东正西负。以本初子午线为中心，每向东一跨过一个时区，时刻增加一个小时，每向西跨过一个时区，时刻减少一个小时。</p>
<ul>
<li>如何理解向东时区增加<blockquote>
<p>由于地球是自西向东转，在地球的某一个地方观察，东边的时间比西边的时间早(东边的人们先看到太阳升起)。<br>想象一下某一个时刻，太阳在你的正上空，此时你所在的地点的时间为正午12点。这时住在你东边的人们，他们看到太阳已经在西边了，他们的时刻是下午，所以往东，时刻增加。</p>
</blockquote>
</li>
</ul>
<h4 id="UTC时间与本地时间的转换"><a href="#UTC时间与本地时间的转换" class="headerlink" title="UTC时间与本地时间的转换"></a>UTC时间与本地时间的转换</h4><p>UTC时间 + 时差 = 本地时间</p>
<h3 id="CST时间"><a href="#CST时间" class="headerlink" title="CST时间"></a>CST时间</h3><p>CST (China Standard Time，中国标准时间) 是UTC+8时区的知名名称之一，比UTC（协调世界时)提前8个小时与UTC的时间偏差可写为+08:00.</p>
<h2 id="http协议里respond的header日期"><a href="#http协议里respond的header日期" class="headerlink" title="http协议里respond的header日期"></a>http协议里respond的header日期</h2><p><img src="/images/time_knowledge/4.png" alt="avatar"></p>
<blockquote>
<p>All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception.<br>格林尼治标准时间。 在HTTP协议中，时间都是用格林尼治标准时间来表示的，而不是本地时间。<br><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2" target="_blank" rel="noopener">RFC 7231, section 7.1.1.2: Date</a></p>
</blockquote>
<h2 id="在java里用到的时间"><a href="#在java里用到的时间" class="headerlink" title="在java里用到的时间"></a>在java里用到的时间</h2><p><img src="/images/time_knowledge/2.png" alt="avatar"></p>
<h3 id="SimpleDateFormat工具"><a href="#SimpleDateFormat工具" class="headerlink" title="SimpleDateFormat工具"></a>SimpleDateFormat工具</h3><ul>
<li>例子如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class UTCTimeFormatTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">        &#x2F;&#x2F;Z代表UTC统一时间:2017-11-27T03:16:03.944Z</span><br><span class="line">        SimpleDateFormat format &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;);</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        String str &#x3D; format.format(date);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        SimpleDateFormat dayformat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        String source &#x3D;&quot;2018-09-18&quot;;        &#x2F;&#x2F;先将年月日的字符串日期格式化为date类型</span><br><span class="line">        Date day &#x3D; dayformat.parse(source);　　　　 &#x2F;&#x2F;然后将date类型的日期转化为UTC格式的时间</span><br><span class="line">        String str2&#x3D; format.format(day);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
打印结果<br><img src="/images/time_knowledge/1.png" alt="avatar"><h3 id="SimpleDateFormat线程不安全"><a href="#SimpleDateFormat线程不安全" class="headerlink" title="SimpleDateFormat线程不安全"></a>SimpleDateFormat线程不安全</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class SimpleDateFormatTest extends Thread &#123;</span><br><span class="line">    private static SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    private String name;</span><br><span class="line">    private String dateStr;</span><br><span class="line"></span><br><span class="line">    public SimpleDateFormatTest(String name, String dateStr) &#123;</span><br><span class="line">        this.dateStr &#x3D; dateStr;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Date date &#x3D; simpleDateFormat.parse(dateStr);</span><br><span class="line">            System.out.println(name + &quot;: date : &quot; + date);</span><br><span class="line">        &#125; catch (ParseException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);</span><br><span class="line">        executorService.execute(new SimpleDateFormatTest(&quot;A&quot;, &quot;2017-01-01&quot;));</span><br><span class="line">        executorService.execute(new SimpleDateFormatTest(&quot;B&quot;, &quot;2020-12-12&quot;));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果<br><img src="/images/time_knowledge/3.png" alt="avatar"><h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4></li>
<li>SimpleDateFormat构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public SimpleDateFormat(String pattern, Locale locale)</span><br><span class="line">&#123;</span><br><span class="line">    if (pattern &#x3D;&#x3D; null || locale &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initializeCalendar(locale);</span><br><span class="line">    this.pattern &#x3D; pattern;</span><br><span class="line">    this.formatData &#x3D; DateFormatSymbols.getInstanceRef(locale);</span><br><span class="line">    this.locale &#x3D; locale;</span><br><span class="line">    initialize(locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>initializeCalendar初始化calendar方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initializeCalendar(Locale loc) &#123;</span><br><span class="line">    if (calendar &#x3D;&#x3D; null) &#123;</span><br><span class="line">        assert loc !&#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; The format object must be constructed using the symbols for this zone.</span><br><span class="line">        &#x2F;&#x2F; However, the calendar should use the current default TimeZone.</span><br><span class="line">        &#x2F;&#x2F; If this is not contained in the locale zone strings, then the zone</span><br><span class="line">        &#x2F;&#x2F; will be formatted using generic GMT+&#x2F;-H:MM nomenclature.</span><br><span class="line">        calendar &#x3D; Calendar.getInstance(TimeZone.getDefault(), loc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>calendar变量的构造过程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static Calendar getInstance(TimeZone zone, Locale aLocale)</span><br><span class="line">&#123;</span><br><span class="line">    return createCalendar(zone, aLocale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Calendar createCalendar(TimeZone zone, Locale aLocale)</span><br><span class="line">&#123;</span><br><span class="line">    CalendarProvider provider &#x3D;</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                .getCalendarProvider();</span><br><span class="line">    if (provider !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">            &#x2F;&#x2F; fall back to the default instantiation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">        if (caltype !&#x3D; null) &#123;</span><br><span class="line">            switch (caltype) &#123;</span><br><span class="line">            case &quot;buddhist&quot;:</span><br><span class="line">            cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;japanese&quot;:</span><br><span class="line">                cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;gregory&quot;:</span><br><span class="line">                cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cal &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; If no known calendar type is explicitly specified,</span><br><span class="line">        &#x2F;&#x2F; perform the traditional way to create a Calendar:</span><br><span class="line">        &#x2F;&#x2F; create a BuddhistCalendar for th_TH locale,</span><br><span class="line">        &#x2F;&#x2F; a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">        &#x2F;&#x2F; a GregorianCalendar for any other locales.</span><br><span class="line">        &#x2F;&#x2F; NOTE: The language, country and variant strings are interned.</span><br><span class="line">        if (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;</span><br><span class="line">            cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;</span><br><span class="line">                    &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;JP&quot;) &#123;</span><br><span class="line">            cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过查看源码发现，原来SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题,如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</p>
</blockquote>
</li>
</ul>
<h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4><ul>
<li>将SimpleDateFormat定义成局部变量<blockquote>
<p>缺点是每次调用方法后都会实例化一个SimpleDateFormat对象，方法结束后会被垃圾回收</p>
</blockquote>
</li>
<li>如果要定义成静态变量，一定要加锁，保证同一个时刻就只有一个线程可以访问到SimpleDateFormat对象<blockquote>
<p>缺点是性能变差，每次都得等待锁释放后其他线程才能访问SimpleDateFormat对象</p>
</blockquote>
</li>
<li><p>使用ThreadLocal来保存SimpleDateFormat对象，每个线程拥有自己的SimpleDateFormat对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class DateUtils &#123;</span><br><span class="line">    &#x2F;&#x2F; 单例</span><br><span class="line">    private static Map&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt; localMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private static final Object lockObject &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public static SimpleDateFormat getSimpleDateFormat(String pattern) &#123;</span><br><span class="line">        ThreadLocal&lt;SimpleDateFormat&gt; threadLocal &#x3D; localMap.get(pattern);</span><br><span class="line">        if (threadLocal &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 加锁，不重复初始化已经存在的pattern</span><br><span class="line">            synchronized (lockObject) &#123;</span><br><span class="line">                &#x2F;&#x2F; 再取一次是为了防止localMap被重复多次put已存在的pattern</span><br><span class="line">                threadLocal &#x3D; localMap.get(pattern);</span><br><span class="line">                if (threadLocal &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    System.out.println(&quot;put new sdf of pattern &quot; + pattern + &quot; to map&quot;);</span><br><span class="line">                    threadLocal &#x3D; new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">                            System.out.println(&quot;thread: &quot; + Thread.currentThread() + &quot; init pattern: &quot; + pattern);</span><br><span class="line">                            return new SimpleDateFormat(pattern);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    localMap.put(pattern, threadLocal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String format(Date date, String pattern) &#123;</span><br><span class="line">        return getSimpleDateFormat(pattern).format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Date parse(String dateString, String pattern) throws ParseException &#123;</span><br><span class="line">        return getSimpleDateFormat(pattern).parse(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h4><p><img src="/images/time_knowledge/5.png" alt="avatar"></p>
<blockquote>
<p>ThreadLocal是用哈希表实现的，每个线程里都有一个ThreadLocalMap，就是以Map的形式存储多个ThreadLocal对象，当线程调用ThreadLocal操作方法时，都会通过当前线程Thread对象拿到ThreadLocalMap，再通过ThreadLocal对象从ThreadLocalMap中锁定数据实体（ThreadLocal.Entry）</p>
</blockquote>
</li>
<li><p>ThreadLocal.set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 取出Thread.ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    &#x2F;&#x2F; 已存在，则更新</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">    &#x2F;&#x2F; 否则创建map</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ThreadLocalMap.set方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Set the value associated with key.</span><br><span class="line">*</span><br><span class="line">* @param key the thread local object</span><br><span class="line">* @param value the value to be set</span><br><span class="line">*&#x2F;</span><br><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">    &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">    &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">    &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    for (Entry e &#x3D; tab[i];</span><br><span class="line">            e !&#x3D; null;</span><br><span class="line">            e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ThreadLocal.createMap方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create the map associated with a ThreadLocal. Overridden in</span><br><span class="line">* InheritableThreadLocal.</span><br><span class="line">*</span><br><span class="line">* @param t the current thread</span><br><span class="line">* @param firstValue value for the initial entry of the map</span><br><span class="line">*&#x2F;</span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 实例化一个新ThreadLocalMap对象</span><br><span class="line">    &#x2F;&#x2F; this就是操作的ThreadLocal对象，firstValue就是要保存的值</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SimpleDateFormat挖坑自跳"><a href="#SimpleDateFormat挖坑自跳" class="headerlink" title="SimpleDateFormat挖坑自跳"></a>SimpleDateFormat挖坑自跳</h3><h4 id="坑王举例"><a href="#坑王举例" class="headerlink" title="坑王举例"></a>坑王举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line">public class SimpleDateFormatErrorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String date1 &#x3D; &quot;2021-05-01&quot;;</span><br><span class="line">            SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">            System.out.println(simpleDateFormat.parse(date1));</span><br><span class="line">        &#125; catch (ParseException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下<br><img src="/images/time_knowledge/6.png" alt="avatar"><br>这个代码预期是会走到catch的exception里，但是却正常打印输出了</p>
<h4 id="SimpleDateFormat-parse源码解析"><a href="#SimpleDateFormat-parse源码解析" class="headerlink" title="SimpleDateFormat.parse源码解析"></a>SimpleDateFormat.parse源码解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Date parse(String text, ParsePosition pos)</span><br><span class="line">&#123;</span><br><span class="line">    checkNegativeNumberExpression();</span><br><span class="line"></span><br><span class="line">    int start &#x3D; pos.index;</span><br><span class="line">    int oldStart &#x3D; start;</span><br><span class="line">    int textLength &#x3D; text.length();</span><br><span class="line"></span><br><span class="line">    boolean[] ambiguousYear &#x3D; &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">    CalendarBuilder calb &#x3D; new CalendarBuilder();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">        int tag &#x3D; compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">        int count &#x3D; compiledPattern[i++] &amp; 0xff;</span><br><span class="line">        if (count &#x3D;&#x3D; 255) &#123;</span><br><span class="line">            count &#x3D; compiledPattern[i++] &lt;&lt; 16;</span><br><span class="line">            count |&#x3D; compiledPattern[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (tag) &#123;</span><br><span class="line">        case TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">            if (start &gt;&#x3D; textLength || text.charAt(start) !&#x3D; (char)count) &#123;</span><br><span class="line">                pos.index &#x3D; oldStart;</span><br><span class="line">                pos.errorIndex &#x3D; start;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TAG_QUOTE_CHARS:</span><br><span class="line">            while (count-- &gt; 0) &#123;</span><br><span class="line">                if (start &gt;&#x3D; textLength || text.charAt(start) !&#x3D; compiledPattern[i++]) &#123;</span><br><span class="line">                    pos.index &#x3D; oldStart;</span><br><span class="line">                    pos.errorIndex &#x3D; start;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;&#x2F; 进入默认配置</span><br><span class="line">        default:</span><br><span class="line">            &#x2F;&#x2F; Peek the next pattern to determine if we need to</span><br><span class="line">            &#x2F;&#x2F; obey the number of pattern letters for</span><br><span class="line">            &#x2F;&#x2F; parsing. It&#39;s required when parsing contiguous</span><br><span class="line">            &#x2F;&#x2F; digit text (e.g., &quot;20010704&quot;) with a pattern which</span><br><span class="line">            &#x2F;&#x2F; has no delimiters between fields, like &quot;yyyyMMdd&quot;.</span><br><span class="line">            boolean obeyCount &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 在阿拉伯语中，负数的减号可以放在数字的后面（1111-）</span><br><span class="line">            &#x2F;&#x2F; In Arabic, a minus sign for a negative number is put after</span><br><span class="line">            &#x2F;&#x2F; the number. Even in another locale, a minus sign can be</span><br><span class="line">            &#x2F;&#x2F; put after a number using DateFormat.setNumberFormat().</span><br><span class="line">            &#x2F;&#x2F; If both the minus sign and the field-delimiter are &#39;-&#39;,</span><br><span class="line">            &#x2F;&#x2F; subParse() needs to determine whether a &#39;-&#39; after a number</span><br><span class="line">            &#x2F;&#x2F; in the given text is a delimiter or is a minus sign for the</span><br><span class="line">            &#x2F;&#x2F; preceding number. We give subParse() a clue based on the</span><br><span class="line">            &#x2F;&#x2F; information in compiledPattern.</span><br><span class="line">            boolean useFollowingMinusSignAsDelimiter &#x3D; false;</span><br><span class="line"></span><br><span class="line">            if (i &lt; compiledPattern.length) &#123;</span><br><span class="line">                int nextTag &#x3D; compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">                if (!(nextTag &#x3D;&#x3D; TAG_QUOTE_ASCII_CHAR ||</span><br><span class="line">                        nextTag &#x3D;&#x3D; TAG_QUOTE_CHARS)) &#123;</span><br><span class="line">                    obeyCount &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (hasFollowingMinusSign &amp;&amp;</span><br><span class="line">                    (nextTag &#x3D;&#x3D; TAG_QUOTE_ASCII_CHAR ||</span><br><span class="line">                        nextTag &#x3D;&#x3D; TAG_QUOTE_CHARS)) &#123;</span><br><span class="line">                    int c;</span><br><span class="line">                    if (nextTag &#x3D;&#x3D; TAG_QUOTE_ASCII_CHAR) &#123;</span><br><span class="line">                        c &#x3D; compiledPattern[i] &amp; 0xff;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c &#x3D; compiledPattern[i+1];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (c &#x3D;&#x3D; minusSign) &#123;</span><br><span class="line">                        useFollowingMinusSignAsDelimiter &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start &#x3D; subParse(text, start, tag, count, obeyCount,</span><br><span class="line">                                ambiguousYear, pos,</span><br><span class="line">                                useFollowingMinusSignAsDelimiter, calb);</span><br><span class="line">            if (start &lt; 0) &#123;</span><br><span class="line">                pos.index &#x3D; oldStart;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; At this point the fields of Calendar have been set.  Calendar</span><br><span class="line">    &#x2F;&#x2F; will fill in default values for missing fields when the time</span><br><span class="line">    &#x2F;&#x2F; is computed.</span><br><span class="line"></span><br><span class="line">    pos.index &#x3D; start;</span><br><span class="line"></span><br><span class="line">    Date parsedDate;</span><br><span class="line">    try &#123;</span><br><span class="line">        parsedDate &#x3D; calb.establish(calendar).getTime();</span><br><span class="line">        &#x2F;&#x2F; If the year value is ambiguous,</span><br><span class="line">        &#x2F;&#x2F; then the two-digit year &#x3D;&#x3D; the default start year</span><br><span class="line">        if (ambiguousYear[0]) &#123;</span><br><span class="line">            if (parsedDate.before(defaultCenturyStart)) &#123;</span><br><span class="line">                parsedDate &#x3D; calb.addYear(100).establish(calendar).getTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; An IllegalArgumentException will be thrown by Calendar.getTime()</span><br><span class="line">    &#x2F;&#x2F; if any fields are out of range, e.g., MONTH &#x3D;&#x3D; 17.</span><br><span class="line">    catch (IllegalArgumentException e) &#123;</span><br><span class="line">        pos.errorIndex &#x3D; start;</span><br><span class="line">        pos.index &#x3D; oldStart;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return parsedDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>正确姿势<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line">public class SimpleDateFormatErrorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String date1 &#x3D; &quot;2021-05-01&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">            &#x2F;&#x2F; 设置为严格模式,Calendar类默认把lenient设置为true，意思是宽松模式解析</span><br><span class="line">            simpleDateFormat.setLenient(false);</span><br><span class="line">            System.out.println(simpleDateFormat.parse(date1));</span><br><span class="line">        &#125; catch (ParseException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果，看到已经抛出异常了<br><img src="/images/time_knowledge/7.png" alt="avatar"><h4 id="坑爹举例"><a href="#坑爹举例" class="headerlink" title="坑爹举例"></a>坑爹举例</h4></li>
<li>代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line">public class SimpleDateFormatErrorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String date1 &#x3D; &quot;2021-05-01&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);</span><br><span class="line">            &#x2F;&#x2F; 设置为严格模式</span><br><span class="line">            simpleDateFormat.setLenient(false);</span><br><span class="line">            System.out.println(simpleDateFormat.parse(date1));</span><br><span class="line">        &#125; catch (ParseException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
打印结果，输出是2020-12-27<br><img src="/images/time_knowledge/8.png" alt="avatar"></li>
<li>详解<br><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">官方文档</a>  </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字母</th>
<th style="text-align:right">日期含义</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">y</td>
<td style="text-align:right">year</td>
<td style="text-align:center">正常年份</td>
</tr>
<tr>
<td style="text-align:left">Y</td>
<td style="text-align:right">week year</td>
<td style="text-align:center">按周算的年份，比如2018年12月31日，正好是2019 Week-year的第一周第一天</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:right">Day in year</td>
<td style="text-align:center">一年中的第几天</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:right">Day in month</td>
<td style="text-align:center">正常日期的日</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/20/thread-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/20/thread-basic/" class="post-title-link" itemprop="url">线程知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-20 16:09:55" itemprop="dateCreated datePublished" datetime="2021-10-20T16:09:55+08:00">2021-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><blockquote>
<p>进程是一个具有独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统调度和进行资源分配和调度的一个独立单位，进程一般由程序、数据集合、进程控制块三部分组成</p>
<ul>
<li>程序：用于描述进程要完成的功能，是控制进程执行的指令集</li>
<li>数据集合：程序在执行时所需要的数据和工作区</li>
<li>进程控制块：Program Control Block，简称PCB，包含进程的描述信息和控制信息，是进程存在的唯一标示<br>进程由内存空间（代码、数据、进程空间、打开的文件）和一个或者多个线程组成<h3 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h3>线程是程序执行流的最小单元，是处理器调度和分派的基本单位，一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成</li>
<li>什么是时间片<br>大部分操作系统（windows、linux）的任务调度都是采用时间片轮转的方式进行抢占式调度，在一个进程中，当 一个线程任务执行几毫秒后，会有操作系统的内核进行调度，通过硬件的计数器中断处理器让该线程强制暂停并将该线程的寄存器暂存到内存中，通过查看线程列表来决定下一个线程的执行，并从内存中恢复该线程的寄存器，在这个过程中，任务执行的那一小段时间就叫时间片，任务正在执行的状态就叫运行状态（RUNNABLE），被暂停的线程任务状态就叫就绪状态（WAITING），意为等待下一个时间片的到来。<br><img src="/images/java_thread_basic/1.png" alt="avatar"><h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3></li>
<li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多<br><img src="/images/java_thread_basic/2.png" alt="avatar"><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3>多核处理器是指一个处理器上集成多个运算核心，从而提高计算能力，每一个处理核心对应一个内核线程<br>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程映射到各个处理器上，一般一个处理核心对应一个内核线程<h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3>轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。</li>
</ul>
</blockquote>
<h3 id="线程状态介绍"><a href="#线程状态介绍" class="headerlink" title="线程状态介绍"></a>线程状态介绍</h3><blockquote>
<p>java.lang.Thread 类定义了枚举类型State，包含Thread的所有状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block&#x2F;method or</span><br><span class="line">         * reenter a synchronized block&#x2F;method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><img src="/images/java_thread_basic/2.png" alt="avatar"></p>
<ul>
<li><ol>
<li>初始状态(NEW)<br>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过Thread类</span><br><span class="line">Thread thread &#x3D; new Thread();</span><br><span class="line">&#x2F;&#x2F; 通过Runnable接口</span><br><span class="line">Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol>
<li>就绪状态(RUNNABLE)</li>
</ol>
<ul>
<li><ol>
<li>READY<br>就绪状态只是说你有资格运行，调度程序没有挑选到你，你就永远是就绪状态。<br>调用线程的start()方法，此线程进入就绪状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。<br>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。<br>锁池里的线程拿到对象锁后，进入就绪状态。</li>
</ol>
</li>
<li><ol>
<li>RUNNING<br>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><ol>
<li>阻塞状态(BLOCKED)<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrencyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object lock &#x3D; new Object();</span><br><span class="line">        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(10,10,0, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">        for (int i &#x3D; 0; i&lt; 11; i++) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    synchronized (lock) &#123;</span><br><span class="line">                        System.out.println(&quot;try to refresh config&quot;);</span><br><span class="line">                        Thread.sleep(3*60*1000);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executor.submit(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol>
<li>等待(WAITING)<br>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Thread t &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;hello&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(&quot;start&quot;);</span><br><span class="line">  &#x2F;&#x2F; 调用start方法，t线程从NEW状态-》runnable状态</span><br><span class="line">  t.start();</span><br><span class="line">  &#x2F;&#x2F; 调用join方法，让main线程处于waiting状态，先执行t线程的start-》hello，t线程执行结束后处于terminated，main线程从waiting状态恢复到runnable状态，执行自己的的end</span><br><span class="line">  t.join();</span><br><span class="line">  System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/images/java_thread_basic/7.png" alt="avatar"></li>
</ol>
</li>
<li><ol>
<li>超时等待(TIMED_WAITING)<br>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前main线程处于RUNNABLE状态</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用sleep后，main线程进入TIMED_WAITING状态</span><br><span class="line">      Thread.sleep(10000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 休眠结束后，恢复RUNNABLE状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/images/java_thread_basic/6.png" alt="avatar"></li>
</ol>
</li>
<li><ol>
<li>终止状态(TERMINATED)<br>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li>
</ol>
</li>
</ul>
<h3 id="线程的应用实践"><a href="#线程的应用实践" class="headerlink" title="线程的应用实践"></a>线程的应用实践</h3><ul>
<li>Thread类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadStatusTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;1&#x3D;&#x3D;&quot;+t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;2&#x3D;&#x3D;&quot;+t.getState());</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;3&#x3D;&#x3D;&quot;+t.getState());</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上图<br><img src="/images/java_thread_basic/4.png" alt="avatar"><br><img src="/images/java_thread_basic/5.png" alt="avatar"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/17/thread-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/17/thread-pool/" class="post-title-link" itemprop="url">线程池相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-17 10:09:55" itemprop="dateCreated datePublished" datetime="2021-10-17T10:09:55+08:00">2021-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="如何判断程序类型"><a href="#如何判断程序类型" class="headerlink" title="如何判断程序类型"></a>如何判断程序类型</h3><ul>
<li><p>CPU密集型</p>
<blockquote>
<p> <code>CPU</code> 密集型简单理解就是利用 <code>CPU</code> 计算能力的任务,比如你在内存中对大量数据进行排序</p>
</blockquote>
</li>
<li><p>I/O密集型</p>
<blockquote>
<p>但凡涉及到网络读取，文件读取这类都是 <code>IO</code> 密集型，这类任务的特点是 <code>CPU</code> 计算耗费时间相比于等待 <code>IO</code> 操作完成的时间来说很少，大部分时间都花在了等待 <code>IO</code> 操作完成上。</p>
</blockquote>
</li>
</ul>
<h3 id="线程池设置"><a href="#线程池设置" class="headerlink" title="线程池设置"></a>线程池设置</h3><ul>
<li><p>CPU 密集型任务(CPU核数 + 1)： </p>
<blockquote>
<p>这种任务消耗的主要是 <code>CPU</code> 资源，可以将线程数设置为 <code>N</code>（<code>CPU</code> 核心数）+1，比 <code>CPU</code> 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，<code>CPU</code> 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
</blockquote>
</li>
<li><p>I/O 密集型任务(CPU核数 * 2)： </p>
<blockquote>
<p>这种任务应用起来，系统会用大部分的时间来处理 <code>I/O</code> 交互，而线程在处理 <code>I/O</code> 的时间段内不会占用 <code>CPU</code> 来处理，这时就可以将 <code>CPU</code> 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p>
</blockquote>
</li>
<li><p>参数介绍</p>
<ul>
<li>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</li>
<li>maximumPoolSize：当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数</li>
<li>workQueue：当新任务来的时候，先判断当前运行的线程数量是否达到核心线程数（corePoolSize），如果达到，则新任务会被存放到队列中</li>
<li>keepAliveTime：当线程池中的线程数量大于核心线程池（corePoolSize）时，如果没有新任务提交，核心线程外的线程（maximumPoolSize - corePoolSize）不会被立即销毁，而是等到keepAliveTime时间后，才会被回收销毁</li>
<li>unit：keepAliveTime的时间单位（TimeUnit类中的成员变量）</li>
<li>threadFactory：executor创建线程的工厂类</li>
<li>handler：饱和策略<blockquote>
<p>如果当前同时运行的线程数量达到最大线程数（maximumPoolSize），并且队列（workQueue）已经满了，ThreadPoolExecutory就会执行一些策略</p>
<ul>
<li>AbortPolicy：抛出 RejectExecutionExeception 来拒绝新任务加入 （默认）</li>
<li>CallerRunsPolicy：调用执行自己的线程运行拒绝任务</li>
<li>DiscardPolicy：不处理新任务，直接丢弃</li>
<li>DiscardOldestPolicy：丢弃最早的未处理的任务</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/images/java_thread_pool/1.png" alt="avatar"></p>
<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><ul>
<li><p>ThreadPoolExecutor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ThreadPoolExecutor类 继承了 AbstractExecutorService类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;</span><br></pre></td></tr></table></figure>
<p>AbstractExecutorService类 实现了 ExecutorService接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br></pre></td></tr></table></figure>
<p>ExecutorService接口 继承了 Executor类</p>
</blockquote>
</li>
<li><p>线程池demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package blank.lin.thread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolTest &#123;</span><br><span class="line">    private static ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">            1,</span><br><span class="line">            2,</span><br><span class="line">            0L,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;第1个任务执行完成&quot;);</span><br><span class="line">                &#125; catch (Exception exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;加入第1个任务，线程池刚刚初始化，没有可以执行任务的核心线程，创建一个核心线程来执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;第2个任务执行完成&quot;);</span><br><span class="line">                &#125; catch (Exception exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;加入第2个任务，没有可以执行任务的核心线程，且任务数大于corePoolSize，新加入任务被放在了阻塞队列中&quot;);</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;第3个任务执行完成&quot;);</span><br><span class="line">                &#125; catch (Exception exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;加入第3个任务，此时，阻塞队列已满，新建非核心线程执行新加入任务&quot;);</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;第4个任务执行完成&quot;);</span><br><span class="line">                &#125; catch (Exception exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;加入第4个任务，此时，阻塞队列已满，新建非核心线程执行新加入任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(600);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;第1个任务执行完毕，核心线程空闲，阻塞队列的任务被取出来，使用核心线程来执行&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(600);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;第2个任务执行完毕，核心线程空闲，非核心线程在执行第3个任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(600);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printCount();</span><br><span class="line">        System.out.println(&quot;第3个任务执行完毕，非核心线程被销毁，核心线程保留&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printCount() &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;当前活跃线程数:&quot;+threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(&quot;当前核心线程数:&quot;+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(&quot;阻塞队列中的任务数:&quot;+threadPoolExecutor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>threadPoolExecutor.execute源码分析</p>
<blockquote>
<p>处理过程一共3步  </p>
</blockquote>
<ul>
<li>首先判断核心线程池是否满了，未满则开启新线程执行任务，addWorker调用会原子性检查线程运行状态和线程数，并且<blockquote>
<ol>
<li>If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task.  The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn’t, by returning false.</li>
</ol>
</blockquote>
</li>
<li>如果一个任务被成功加入到队列里，也会重复检查是否应该新添加一个线程去执行，因为自上次检查后现存线程可以已死，或者线程池在进入这个方法后就关闭了，所以我们会重复检查状态，并且判断是否需要回滚队列，或者开启新线程<blockquote>
<ol>
<li>If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none.</li>
</ol>
</blockquote>
</li>
<li>如果无法加入队列任务，我们会尝试新添加一个线程，如果新线程添加失败，我们知道线程被关闭了或者已经满了，所以任务会被拒绝<blockquote>
<ol>
<li>If we cannot queue task, then we try to add a new thread.  If it fails, we know we are shut down or saturated and so reject the task.  </li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>源码   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        &#x2F;&#x2F; 任务为空，抛异常</span><br><span class="line">        if (command &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">         &#x2F;&#x2F; ctl中保存的线程池当前的一些任务状态</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 上面介绍的3步从这里开始</span><br><span class="line">        &#x2F;&#x2F; 第一步，判断当前线程池中的任务数量是否小于核心线程数</span><br><span class="line">        &#x2F;&#x2F; 如果小于的话通过addWorker新建一个线程，并将任务添加到线程去执行</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c &#x3D; ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第二步，如果当前线程数已经大于等于核心线程数了</span><br><span class="line">        &#x2F;&#x2F; 通过isRunning来判断线程池状态，线程池处于RUNNING状态，才会将任务加入到workQueue队列中</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck &#x3D; ctl.get();</span><br><span class="line">            &#x2F;&#x2F; 再次获取线程池状态，如果线程池不是RUNNING状态了，就需要从workQueue中移除任务</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                &#x2F;&#x2F; 执行拒绝策略</span><br><span class="line">                reject(command);</span><br><span class="line">            &#x2F;&#x2F; 当前线程池为空，则重新创建线程去执行任务</span><br><span class="line">            else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第三步</span><br><span class="line">        &#x2F;&#x2F; 创建线程执行任务失败，执行相应的拒绝任务</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<img src="/images/java_thread_pool/2.png" alt="avatar"></li>
</ul>
<h3 id="查看机器cpu信息"><a href="#查看机器cpu信息" class="headerlink" title="查看机器cpu信息"></a>查看机器cpu信息</h3><ul>
<li><p>查看物理cpu个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br></pre></td></tr></table></figure>
<p><img src="/images/java_thread_pool/4.png" alt="avatar"></p>
</li>
<li><p>查看每个物理cpu中core的个数（即核数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br></pre></td></tr></table></figure>
<p><img src="/images/java_thread_pool/5.png" alt="avatar"></p>
</li>
<li><p>查看逻辑cpu的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">&#x2F;&#x2F; 在java里也可以这样查询</span><br><span class="line">Runtime.getRuntime().avaliableProcessor();</span><br></pre></td></tr></table></figure>
<p><img src="/images/java_thread_pool/3.png" alt="avatar"></p>
</li>
<li><p>查看cpu型号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep name | uniq | cut -f2 -d:</span><br></pre></td></tr></table></figure>
<p><img src="/images/java_thread_pool/6.png" alt="avatar"></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/10/java-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/10/java-interview/" class="post-title-link" itemprop="url">java面试常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-10 10:09:55" itemprop="dateCreated datePublished" datetime="2021-10-10T10:09:55+08:00">2021-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li>目的：参数化类型</li>
<li>用法：泛型类、泛型接口、泛型方法<ul>
<li>泛型类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单范型</span><br><span class="line">class Test&lt;T&gt; &#123;</span><br><span class="line">  private T var;</span><br><span class="line">  public T getVar() &#123;</span><br><span class="line">    return var;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setVar(T var) &#123;</span><br><span class="line">    this.var &#x3D; var;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 多元泛型</span><br><span class="line">class TestKV&lt;K,V&gt; &#123;</span><br><span class="line">  private K key;</span><br><span class="line">  private V value;</span><br><span class="line">  public K getKey() &#123;</span><br><span class="line">    return key;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setKey(K key) &#123;</span><br><span class="line">    this.key &#x3D; key;</span><br><span class="line">  &#125;</span><br><span class="line">  public V getValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setValue(V value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Test&lt;String&gt; test &#x3D; new Test&lt;String&gt;();</span><br><span class="line">    test.setVar(&quot;aa&quot;);</span><br><span class="line">    System.out.println(test.getVar());</span><br><span class="line"></span><br><span class="line">    TestKV&lt;String, String&gt; testKV &#x3D; new TestKV&lt;String, String&gt;();</span><br><span class="line">    testKV.setKey(&quot;hello&quot;);</span><br><span class="line">    testKV.setValue(&quot;world&quot;);</span><br><span class="line">    System.out.println(testKV.getKey() +&quot;:&quot;+testKV.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Test&lt;T&gt; &#123;</span><br><span class="line">  public T getVar();</span><br><span class="line">&#125;</span><br><span class="line">class TestImpl&lt;T&gt; implement Test&lt;T&gt; &#123;</span><br><span class="line">  private T var;</span><br><span class="line">  public TEstImpl(T var) &#123;</span><br><span class="line">    this.var &#x3D; var;</span><br><span class="line">  &#125;</span><br><span class="line">  public T getVar() &#123;</span><br><span class="line">    return var;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setVar(T var) &#123;</span><br><span class="line">    this.var &#x3D; var;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Test&lt;String&gt; test &#x3D; new TestImpl&lt;String&gt;(&quot;tom&quot;);</span><br><span class="line">    System.out.pringln(test.getVar());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public &lt;T&gt; T getObject(Class&lt;T&gt; c) &#123;</span><br><span class="line">    T t &#x3D; c.newInstance();</span><br><span class="line">    retrun t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/02/wireshard3.4.8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/02/wireshard3.4.8/" class="post-title-link" itemprop="url">wireshark3.4.8保姆级入门教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-02 10:09:55" itemprop="dateCreated datePublished" datetime="2021-10-02T10:09:55+08:00">2021-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 18:09:00" itemprop="dateModified" datetime="2022-08-22T18:09:00+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/introduction/" itemprop="url" rel="index"><span itemprop="name">introduction</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="wireshark3-4-8，主界面"><a href="#wireshark3-4-8，主界面" class="headerlink" title="wireshark3.4.8，主界面"></a>wireshark3.4.8，主界面</h2><p><img src="/images/wireshark/1.png" alt="avatar"></p>
<h2 id="通过ping简单入门"><a href="#通过ping简单入门" class="headerlink" title="通过ping简单入门"></a>通过ping简单入门</h2><ul>
<li>启动wireshark后，wireshark处于抓包状态中<br><img src="/images/wireshark/2.png" alt="avatar"></li>
<li>在终端输入ping命令后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<img src="/images/wireshark/3.png" alt="avatar"></li>
<li>通过过滤栏设置过滤条件进行数据包列表过滤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr &#x3D;&#x3D; 180.101.49.12 and icmp</span><br></pre></td></tr></table></figure>
<img src="/images/wireshark/4.png" alt="avatar"></li>
</ul>
<blockquote>
<p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP协议是一种面向无连接的协议。</p>
</blockquote>
<h2 id="wireshark抓包界面介绍"><a href="#wireshark抓包界面介绍" class="headerlink" title="wireshark抓包界面介绍"></a>wireshark抓包界面介绍</h2><p><img src="/images/wireshark/5.png" alt="avatar"></p>
<ul>
<li>Display Filter(显示过滤器)，  用于设置过滤条件进行数据包列表过滤。菜单路径：Analyze —&gt; Display Filters。</li>
<li>Packet List Pane(数据包列表)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示</li>
<li>Packet Details Pane(数据包详细信息), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为<br>（1）Frame:   物理层的数据帧概况<br>（2）Ethernet II: 数据链路层以太网帧头部信息<br>（3）Internet Protocol Version 4: 互联网层IP包头部信息<br>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP<br>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议<br><img src="/images/wireshark/6.png" alt="avatar"></li>
</ul>
<h3 id="TCP包的具体内容"><a href="#TCP包的具体内容" class="headerlink" title="TCP包的具体内容"></a>TCP包的具体内容</h3><p><img src="/images/wireshark/7.png" alt="avatar"></p>
<h3 id="抓包过滤器语法"><a href="#抓包过滤器语法" class="headerlink" title="抓包过滤器语法"></a>抓包过滤器语法</h3><ul>
<li>抓包过滤器语法和实例<blockquote>
<p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）</p>
</blockquote>
</li>
</ul>
<p>（1）协议过滤</p>
<p>  比较简单，直接在抓包过滤框中直接输入协议名即可。</p>
<p>  TCP，只显示TCP协议的数据包列表</p>
<p>  HTTP，只查看HTTP协议的数据包列表</p>
<p>  ICMP，只显示ICMP协议的数据包列表</p>
<p>（2）IP过滤</p>
<p>  host 192.168.1.104</p>
<p>  src host 192.168.1.104</p>
<p>  dst host 192.168.1.104</p>
<p>（3）端口过滤</p>
<p>  port 80</p>
<p>  src port 80</p>
<p>  dst port 80</p>
<p>（4）逻辑运算符&amp;&amp; 与、|| 或、！非</p>
<p>  src host 192.168.1.104 &amp;&amp; dst port 80 抓取主机地址为192.168.1.80、目的端口为80的数据包</p>
<p>  host 192.168.1.104 || host 192.168.1.102 抓取主机为192.168.1.104或者192.168.1.102的数据包</p>
<p>  ！broadcast 不抓取广播数据包</p>
<p>2、显示过滤器语法和实例</p>
<p>（1）比较操作符</p>
<p>  比较操作符有== 等于、！= 不等于、&gt; 大于、&lt; 小于、&gt;= 大于等于、&lt;=小于等于。</p>
<p>（2）协议过滤</p>
<p>  比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。</p>
<p>  tcp，只显示TCP协议的数据包列表</p>
<p>  http，只查看HTTP协议的数据包列表</p>
<p>  icmp，只显示ICMP协议的数据包列表  </p>
<p>（3） ip过滤</p>
<p>   ip.src ==192.168.1.104 显示源地址为192.168.1.104的数据包列表</p>
<p>   ip.dst==192.168.1.104, 显示目标地址为192.168.1.104的数据包列表</p>
<p>   ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为192.168.1.104的数据包列表</p>
<p>（4）端口过滤</p>
<p>  tcp.port ==80,  显示源主机或者目的主机端口为80的数据包列表。</p>
<p>  tcp.srcport == 80,  只显示TCP协议的源主机端口为80的数据包列表。</p>
<p>  tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。  </p>
<p>（5） Http模式过滤</p>
<p>  http.request.method==”GET”,   只显示HTTP GET方法的。</p>
<p>（6）逻辑运算符为 and/or/not</p>
<p>  过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr == 192.168.1.104 and icmp</p>
<h3 id="wireshark抓包分析tcp3次握手"><a href="#wireshark抓包分析tcp3次握手" class="headerlink" title="wireshark抓包分析tcp3次握手"></a>wireshark抓包分析tcp3次握手</h3><blockquote>
<p>以某天气预报api举例,<a href="http://jisutianqi.market.alicloudapi.com/weather/query" target="_blank" rel="noopener">http://jisutianqi.market.alicloudapi.com/weather/query</a></p>
<ul>
<li>启动wireshark</li>
<li>用浏览器访问<a href="http://jisutianqi.market.alicloudapi.com/weather/query" target="_blank" rel="noopener">地址</a></li>
<li>在终端输入，得到实际ip地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping jisutianqi.market.alicloudapi.com</span><br></pre></td></tr></table></figure>
<img src="/images/wireshark/8.png" alt="avatar"></li>
<li>在wireshark上过滤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr &#x3D;&#x3D; 47.97.242.71</span><br></pre></td></tr></table></figure>
<img src="/images/wireshark/9.png" alt="avatar"><br>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</li>
<li>第一次握手抓包<br>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图。<br><img src="/images/wireshark/10.png" alt="avatar"><br>数据包的关键属性如下：<ul>
<li>SYN ：标志位，表示请求建立连接</li>
<li>Seq = 0 ：初始建立连接值为0，数据包的相对序列号从0开始，表示当前还没有发送数据</li>
<li>Ack =0：初始建立连接值为0，已经收到包的数量，表示当前没有接收到数据</li>
</ul>
</li>
<li>第二次握手抓包<br>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图<br><img src="/images/wireshark/11.png" alt="avatar"><br>数据包的关键属性如下：<ul>
<li>[SYN + ACK]: 标志位，同意建立连接，并回送SYN+ACK</li>
<li>Seq = 0 ：初始建立值为0，表示当前还没有发送数据</li>
<li>Ack = 1：表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位。（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）</li>
</ul>
</li>
<li>第三次握手抓包<br>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:<br><img src="/images/wireshark/12.png" alt="avatar"><br>数据包的关键属性如下：<ul>
<li>ACK ：标志位，表示已经收到记录</li>
<li>Seq = 1 ：表示当前已经发送1个数据</li>
<li>Ack = 1 : 表示当前端成功接收的数据位数，虽然服务端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据)。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG。如下<br><img src="/images/wireshark/13.png" alt="avatar"><br>其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：<ul>
<li>SYN表示建立连接，</li>
<li>FIN表示关闭连接，</li>
<li>ACK表示响应，</li>
<li>PSH表示有DATA数据传输，</li>
<li>RST表示连接重置</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/01/clickhouse-mac-compile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blank Lin">
      <meta itemprop="description" content="say something about me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlankLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/01/clickhouse-mac-compile/" class="post-title-link" itemprop="url">mac下编译clickhouse</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-01 10:09:55" itemprop="dateCreated datePublished" datetime="2021-10-01T10:09:55+08:00">2021-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 19:34:56" itemprop="dateModified" datetime="2022-11-29T19:34:56+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><blockquote>
<p>Homebrew要安装正确, 确保/usr/local下面出现各种share/include等目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;zsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;cunkai&#x2F;HomebrewCN&#x2F;raw&#x2F;master&#x2F;Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="安装环境所需插件"><a href="#安装环境所需插件" class="headerlink" title="安装环境所需插件"></a>安装环境所需插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake ninja libtool gettext ccache</span><br></pre></td></tr></table></figure>
<h3 id="修正objcopy的问题"><a href="#修正objcopy的问题" class="headerlink" title="修正objcopy的问题"></a>修正objcopy的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install binutils</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;opt&#x2F;binutils&#x2F;bin&#x2F;objcopy &#x2F;usr&#x2F;local&#x2F;bin&#x2F;objcopy</span><br></pre></td></tr></table></figure>
<h3 id="clion打开clickouse-local不成功，无法正常编译debug"><a href="#clion打开clickouse-local不成功，无法正常编译debug" class="headerlink" title="clion打开clickouse local不成功，无法正常编译debug"></a>clion打开clickouse local不成功，无法正常编译debug</h3><p>1&gt; 安装llvm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install llvm</span><br></pre></td></tr></table></figure><br>2&gt; 配置clion的工具链ToolChain<br><img src="/images/clickhouse/1.png" alt="avatar"><br>cmake和make是新版本就可以了，配置好c和c++编译器(compiler)使用刚装好的llvm下的clang</p>
</blockquote>
<h3 id="安装googletest"><a href="#安装googletest" class="headerlink" title="安装googletest"></a>安装googletest</h3><p>有报错ld: library not found for -lgtest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install googletest</span><br></pre></td></tr></table></figure><br><img src="/images/clickhouse/8.png" alt="avatar"></p>
<h3 id="使用支持ninja的CLion版本-可选-最新版是支持的"><a href="#使用支持ninja的CLion版本-可选-最新版是支持的" class="headerlink" title="使用支持ninja的CLion版本(可选, 最新版是支持的)"></a>使用支持ninja的CLion版本(可选, 最新版是支持的)</h3><blockquote>
<p>CLion中的CMake使用选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_CXX_COMPILER_LAUNCHER&#x3D;ccache</span><br><span class="line">-DCMAKE_BUILD_TYPE&#x3D;Debug</span><br><span class="line">-GNinja</span><br><span class="line">-DENABLE_CLICKHOUSE_ALL&#x3D;OFF</span><br><span class="line">-DENABLE_CLICKHOUSE_SERVER&#x3D;ON</span><br><span class="line">-DENABLE_CLICKHOUSE_CLIENT&#x3D;ON</span><br><span class="line">-DUSE_STATIC_LIBRARIES&#x3D;OFF</span><br><span class="line">-DCLICKHOUSE_SPLIT_BINARY&#x3D;ON</span><br><span class="line">-DSPLIT_SHARED_LIBRARIES&#x3D;ON</span><br><span class="line">-DENABLE_LIBRARIES&#x3D;OFF</span><br><span class="line">-DENABLE_UTILS&#x3D;OFF</span><br><span class="line">-DENABLE_TESTS&#x3D;OFF</span><br><span class="line">-DUSE_ROCKSDB&#x3D;ON</span><br><span class="line">-DENABLE_ROCKSDB&#x3D;ON</span><br><span class="line">-DUSE_INTERNAL_ROCKSDB_LIBRARY&#x3D;ON</span><br><span class="line">-DENABLE_PROTOBUF&#x3D;ON</span><br><span class="line">-DENABLE_GRPC&#x3D;ON</span><br></pre></td></tr></table></figure><br><img src="/images/clickhouse/2.png" alt="avatar"></p>
</blockquote>
<h3 id="点Tools-gt-CMake→Reset-Cache-and-Reload-Project"><a href="#点Tools-gt-CMake→Reset-Cache-and-Reload-Project" class="headerlink" title="点Tools-&gt;CMake→Reset Cache and Reload Project"></a>点Tools-&gt;CMake→Reset Cache and Reload Project</h3><p><img src="/images/clickhouse/3.png" alt="avatar"></p>
<blockquote>
<p>load过程可能会遇到的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at contrib&#x2F;croaring-cmake&#x2F;CMakeLists.txt:22 (add_library):Cannot find source file:…</span><br></pre></td></tr></table></figure><br>执行git submodule update —init —recursive 重新拉取相关依赖</p>
</blockquote>
<h3 id="编译clickhouse-server"><a href="#编译clickhouse-server" class="headerlink" title="编译clickhouse-server"></a>编译clickhouse-server</h3><p>1&gt; 点右上角锤子进行编译<br><img src="/images/clickhouse/4.png" alt="avatar"><br>2&gt; 查看编译进度<br><img src="/images/clickhouse/5.png" alt="avatar"></p>
<h3 id="debug方式运行"><a href="#debug方式运行" class="headerlink" title="debug方式运行"></a>debug方式运行</h3><ul>
<li><ol>
<li>debug时需要指定配置文件config.xml路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--config-file&#x3D;&#x2F;Users&#x2F;blanklin&#x2F;Code&#x2F;cpp&#x2F;clickhouse-debug&#x2F;conf&#x2F;config.xml</span><br></pre></td></tr></table></figure>
<img src="/images/clickhouse/7.png" alt="avatar"></li>
</ol>
</li>
<li><ol>
<li>点右侧的蜘蛛按钮进行debug<br><img src="/images/clickhouse/6.png" alt="avatar"></li>
</ol>
</li>
</ul>
<h3 id="cpp快速入门"><a href="#cpp快速入门" class="headerlink" title="cpp快速入门"></a>cpp快速入门</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; main() 是程序开始执行的地方</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot;; &#x2F;&#x2F; 输出 Hello World</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们讲解一下上面这段程序：</p>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。</li>
<li>using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>// main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>int main() 是主函数，程序从这里开始执行。</li>
<li>cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。</li>
<li>return 0; 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Blank Lin</p>
  <div class="site-description" itemprop="description">say something about me</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Blank Lin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
